# DevSmith Platform - Ultra Budget Mode ($50/month) + Quality Standards

## Cost Target: Under $50/month (including Copilot Pro)

### Model Selection Strategy
- PRIMARY: Use Claude Haiku for ALL code tasks (Cursor Pro+)
- FALLBACK: None - Haiku is sufficient for all work
- SONNET: Use only if explicitly blocked by Haiku limitations (request approval first)
- NEVER: Use Opus for any reason

### Task Routing
1. Code completion → Claude Haiku (Cursor Pro+)
2. Chat/explanation → Claude Haiku (Cursor Pro+)
3. Multi-file edits → Claude Haiku (Cursor Pro+)
4. Test generation → Claude Haiku (Cursor Pro+)
5. Architecture planning → Claude Haiku (request Sonnet only if truly stuck)
6. Critical review → Claude Haiku (Sonnet only with explicit approval)

### Claude API Usage Limits
- Daily budget: $2.00/day max (with Cursor Pro+)
- Weekly budget: $14/week max
- Sonnet quota: ZERO unless explicitly approved (Haiku should handle all)
- Track usage in Cursor dashboard

### Cost Optimization Techniques
- Batch similar requests together
- Use short, focused prompts
- Leverage Cursor Pro+ unlimited usage
- Cache common responses
- Use Haiku for 100% of code tasks

### Workflow
1. Use Claude Haiku for all tasks
2. Only request Sonnet with explicit approval if Haiku truly insufficient
3. Monitor usage in Cursor dashboard
4. Report if hitting surprising limitations

### Copilot Pro Integration
- Keep Copilot Pro active ($10/month)
- Use Copilot for inline suggestions
- Use Claude Haiku (Cursor Pro+) for complex tasks
- Use Haiku for architecture decisions

---

## CRITICAL: Test-Driven Development (TDD) - MANDATORY

**ALL CODE MUST FOLLOW TDD WORKFLOW. NO EXCEPTIONS.**

### TDD Workflow (Red → Green → Refactor)

#### Phase 1: PRE-RED - Validate Structure (2 minutes saves 20+ minutes)
Before writing ANY test, verify structure:
```bash
# 1. Check package directory exists
# 2. Verify shared interfaces consolidated (interfaces.go)
# 3. Run: go build ./path/...  (MUST pass before tests)
# 4. Run: goimports -w ./path/...
# 5. Verify no duplicate type/interface definitions
```

**PRE-RED Checklist:**
- [ ] Package directory exists
- [ ] Shared interfaces in `interfaces.go` (one location only)
- [ ] No duplicate type/interface definitions
- [ ] `go build` succeeds
- [ ] Imports formatted with `goimports`
- [ ] Package declaration matches directory name

#### Phase 2: RED - Write Failing Test
- Write test FIRST before implementation code
- Test should fail with "undefined: NewFeature" or similar
- Tests define expected behavior, not assumptions
- Use table-driven tests for multiple cases
- Commit: `test(scope): add failing test (RED phase)`

#### Phase 3: GREEN - Minimal Implementation
- Write ONLY code needed to pass tests
- No fancy solutions, no premature optimization
- All builds must pass: `go build ./...`
- Commit: `feat(scope): implement feature (GREEN phase)`

#### Phase 4: REFACTOR - Improve Quality
- Improve code while keeping tests green
- Extract constants, improve naming, add documentation
- Run tests after EACH change
- Commit: `refactor(scope): improve error handling`

**VIOLATION DETECTION:**
If you write implementation code WITHOUT tests first, the code is wrong by definition. STOP and write tests first.

### Go TDD Best Practices

1. **Always use `go build` before `go test`**
   - Catches syntax errors early
   - Validates imports compile

2. **Never duplicate interfaces**
   - Define once in `interfaces.go`
   - Other files import from interfaces.go

3. **Test one thing per test**
   - Use sub-tests (t.Run) for variations
   - Clear test names: TestFunctionName_Scenario_Expected

4. **Structure: GIVEN/WHEN/THEN**
   ```go
   func TestExample(t *testing.T) {
       // GIVEN: Setup state
       service := setupTestService(t)
       
       // WHEN: Execute operation
       result, err := service.DoSomething()
       
       // THEN: Verify outcome
       assert.NoError(t, err)
       assert.Equal(t, expected, result)
   }
   ```

5. **Mock external dependencies**
   - Use interfaces for all external services
   - Never mock concrete types
   - Use testify/mock for mock objects

6. **Never commit code that:**
   - Has failing tests
   - Has lower test coverage than before
   - Has unchecked errors
   - Has TODO comments that break builds
   - Bypasses linting checks

### Test Coverage Requirements

**Minimum Coverage by Component:**
- Portal Service: 70% unit tests
- Review Service (5 reading modes): 90% critical paths
- Logging Service: 70% unit tests + WebSocket tests
- Analytics Service: 70% unit tests
- Build Service: 70% unit tests
- All Phase 3 Services: 70% unit tests

**Critical Path = 90% coverage required:**
- Authentication flows
- Review mode implementations (Preview, Skim, Scan, Detailed, Critical)
- Log ingestion and WebSocket streaming
- Database persistence
- Error handling paths

---

## Architectural Standards - ALWAYS FOLLOW

### Reference Documents (READ THESE FIRST)

**MANDATORY READING before implementing ANY feature:**
1. `Requirements.md` - Platform mission, features, tech stack
2. `ARCHITECTURE.md` - System design, mental models, service architecture
3. `DevsmithTDD.md` - TDD workflow, test patterns, quality gates

**Key Sections to Reference:**
- Requirements.md § Mental Models (4 core concepts)
- ARCHITECTURE.md § DevSmith Coding Standards (naming, patterns)
- ARCHITECTURE.md § Service Architecture (bounded contexts per service)
- DevsmithTDD.md § TDD Workflow Best Practices

### The Four Mental Models (EVERY commit must respect these)

1. **Bounded Contexts** - Same entity means different things in different services
   - Portal User ≠ Review User ≠ Logging User
   - NO cross-service imports of models
   - Services communicate via APIs only

2. **Layered Architecture** - Clean separation: Controller → Service → Data
   - Controllers: HTTP handling, input validation only
   - Services: Business logic, external API calls
   - Data: SQL queries, persistence only
   - NO layer mixing (controller calling db directly = FAIL)

3. **Abstraction vs Implementation** - Define interfaces before implementations
   - All external dependencies must be interfaces
   - Service implementations swap out without changing callers
   - Interface in interfaces.go, implementations in services

4. **Scope & Context** - Minimize variable lifespans and visibility
   - No global mutable state
   - Pass dependencies explicitly
   - Function-level scope preferred

### Code Organization - GO Services ONLY

**File Structure:**
```
apps/{service}/
├── handlers/          # HTTP handlers (controllers layer)
├── services/          # Business logic (orchestration layer)
├── db/                # Database queries (data layer)
├── models/            # Data structures
├── templates/         # Templ template files
├── middleware/        # HTTP middleware
└── tests/             # Go test files
```

**Critical Rules:**
- ✅ handlers/ can call services/ and models/
- ✅ services/ can call db/, models/, and other services (via interface)
- ✅ db/ can call models/ only
- ❌ NEVER: handlers/ calling db/ directly (layer violation)
- ❌ NEVER: services/ importing models from other services
- ❌ NEVER: global mutable state (use dependency injection)

### Naming Conventions (ENFORCED)

**Files:**
- Go source: `snake_case.go` (auth_service.go, user_handler.go)
- Templ templates: `snake_case.templ` (home.templ, login_form.templ)
- Test files: `_test.go` suffix (auth_service_test.go)
- SQL migrations: Timestamped (20250118120000_create_users.sql)

**Code (Go):**
- Packages: `lowercase` single word (services, handlers, db)
- Exported: `PascalCase` (User, NewUserService, HandleLogin)
- Unexported: `camelCase` (userData, isAuthenticated)
- Constants: `PascalCase` or `UPPER_SNAKE` (MaxRetries, API_BASE_URL)
- Interfaces: `PascalCase` ending in -er (UserService, AuthProvider)

### Go Handler Pattern (REQUIRED FORMAT)

```go
// handlers/auth.go - Controllers layer
func HandleLogin(c *gin.Context) {
    // 1. Bind and validate input
    var req LoginRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request"})
        return
    }
    
    // 2. Call service layer (NEVER call db directly)
    user, err := services.AuthenticateUser(c.Request.Context(), req.Email)
    if err != nil {
        c.JSON(http.StatusUnauthorized, gin.H{"error": "Auth failed"})
        return
    }
    
    // 3. Return response
    c.JSON(http.StatusOK, gin.H{"success": true, "user": user})
}
```

### Error Handling - CRITICAL

**Go Error Rules:**
- ✅ Check EVERY error: `if err != nil { return err }`
- ✅ Wrap errors: `fmt.Errorf("failed to create user: %w", err)`
- ✅ Log errors with context
- ✅ Return user-friendly error messages
- ❌ NEVER: Ignore errors with `_`
- ❌ NEVER: Return error strings as data
- ❌ NEVER: Log and return same error (do one or other)

**Unchecked Error Detection:**
Before committing, run:
```bash
go vet ./...           # Catches shadowed errors
golangci-lint run .    # Catches unchecked errors (errcheck)
go test -race ./...    # Catches race conditions
```

### Database Design - Per Service Schema

**Schema Isolation:**
- Each service owns one schema (portal, review, logs, analytics)
- NO cross-schema foreign keys
- Services communicate via APIs
- Migrations per service

**Example:**
```sql
-- portal schema (Portal Service owns this)
CREATE SCHEMA portal;
CREATE TABLE portal.users (id SERIAL PRIMARY KEY, ...);

-- review schema (Review Service owns this, NOT portal)
CREATE SCHEMA review;
CREATE TABLE review.sessions (id SERIAL PRIMARY KEY, user_id INT, ...);
-- Note: NO FOREIGN KEY to portal.users, communicates via API
```

### API Design

**URL Structure:**
```
/api/{service}/{resource}/{id?}/{action?}

Examples:
GET  /api/review/sessions          - List
POST /api/review/sessions          - Create
GET  /api/review/sessions/123      - Get by ID
POST /api/review/sessions/123/analyze - Action
```

**Status Codes:**
- 200: Successful GET/PUT/PATCH
- 201: Successful POST (resource created)
- 400: Client error (validation)
- 401: Missing authentication
- 403: Insufficient permissions
- 404: Not found
- 500: Server error

**Error Response Format:**
```json
{
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "User-friendly message",
    "details": {}
  }
}
```

### WebSocket Implementation

**Pattern:**
```go
// handlers/ws.go
func HandleWebSocket(c *gin.Context) {
    ws, err := upgrader.Upgrade(c.Writer, c.Request, nil)
    if err != nil {
        return
    }
    defer ws.Close()
    
    for {
        var msg Message
        if err := ws.ReadJSON(&msg); err != nil {
            return
        }
        
        // Process message
        response := process(msg)
        
        // Send response
        if err := ws.WriteJSON(response); err != nil {
            return
        }
    }
}
```

### Configuration Management

**NEVER hardcode:**
- ❌ API URLs: `const API = "http://localhost:8001"`
- ❌ Database DSN: `const DSN = "postgres://..."`
- ❌ Secrets: `const SECRET = "abc123"`

**Use environment variables:**
- ✅ All URLs from env vars
- ✅ All ports from env vars
- ✅ All secrets from env vars
- ✅ .env.example documents all required variables
- ✅ Startup validation fails if required vars missing

### Pre-commit Validation (AUTOMATED)

**Before ANY commit, run:**
```bash
# Format code
gofmt -w ./...
goimports -w ./...

# Build and test
go build ./...
go test ./...

# Lint comprehensively
golangci-lint run ./...

# Check for race conditions
go test -race ./...
```

**Pre-push Hook enforces:**
- ✅ All tests pass
- ✅ Test compilation works (go test -c)
- ✅ Import resolution works (goimports)
- ✅ No race conditions (go test -race)
- ✅ Code formatted (gofmt)
- ❌ Pushing without passing = BLOCKED

---

## Review App - THE CENTERPIECE

**See Requirements.md § Review Service for complete specification**

The Review Service implements FIVE reading modes - this is the core value proposition:

1. **Preview Mode** - Rapid structural assessment (sub 3 seconds)
2. **Skim Mode** - Abstractions without implementation
3. **Scan Mode** - Targeted semantic search
4. **Detailed Mode** - Line-by-line algorithm explanation
5. **Critical Mode** - Quality evaluation (MOST IMPORTANT)

**EVERY implementation must include tests for all 5 modes.**

See DevsmithTDD.md § Test 2.1-2.5 for Critical Mode testing patterns.

---

## Common Pitfalls - AVOID THESE

### Pitfall 1: No TDD (Code first, tests later)
- ❌ WRONG: Write code, then write tests
- ✅ CORRECT: Write tests first (RED), code passes tests (GREEN), improve code (REFACTOR)

### Pitfall 2: Unchecked Errors
- ❌ WRONG: `db.Close()` (ignoring error)
- ✅ CORRECT: Handle error or explicitly skip: `_ = db.Close()`

### Pitfall 3: Layer Violations
- ❌ WRONG: Handler calling database directly
- ✅ CORRECT: Handler calls service, service calls database

### Pitfall 4: Duplicate Code
- ❌ WRONG: Same logic in two functions
- ✅ CORRECT: Extract to shared function, both call it

### Pitfall 5: Hardcoded Values
- ❌ WRONG: `const URL = "http://localhost:8001"`
- ✅ CORRECT: `url := os.Getenv("API_URL")`

### Pitfall 6: Global Mutable State
- ❌ WRONG: `var db *sql.DB` (package-level global)
- ✅ CORRECT: Pass database as dependency to constructor

### Pitfall 7: Interface in Wrong File
- ❌ WRONG: Interface defined in service_test.go
- ✅ CORRECT: Interface in interfaces.go, imported by service

### Pitfall 8: Skipping Pre-commit Validation
- ❌ WRONG: `git commit --no-verify` (FORBIDDEN)
- ✅ CORRECT: Fix issues locally until pre-commit passes

### Pitfall 9: No Context Passing
- ❌ WRONG: Function doesn't accept context.Context
- ✅ CORRECT: First parameter: `func (s *Service) Do(ctx context.Context, ...)`

### Pitfall 10: Missing Test Coverage
- ❌ WRONG: 40% coverage on critical code
- ✅ CORRECT: 90% coverage on critical paths

### Pitfall 11: ABSOLUTE RULE - NO QUALITY GATE BYPASSES (CRITICAL)

**This is the hardest rule to follow because there are infinite creative ways to bypass quality gates. You MUST recognize all of them.**

#### What Counts as a Bypass (ALL FORBIDDEN)

1. **Direct Bypasses:**
   - ❌ `/nolint` or `// nolint:` comments
   - ❌ `//ignore:` or `//skip:` comments
   - ❌ `git commit --no-verify` (FORBIDDEN)
   - ❌ `git push --no-verify` (FORBIDDEN)
   - ❌ `.gitignore` entries to hide bad files
   - ❌ Disabling linters in config files

2. **Indirect Bypasses (EVEN MORE DANGEROUS):**
   - ❌ "This is a pre-existing failure, I'll skip it"
   - ❌ "This test is flaky, I won't fix it"
   - ❌ "This is old code, I'll leave it broken"
   - ❌ "I'll come back to this later" (you won't)
   - ❌ "This is beyond scope" (fix it anyway)
   - ❌ "The pre-push hook doesn't check this" (it should, or fix the hook)
   - ❌ Accepting test failures as acceptable
   - ❌ Skipping any test run with `-skip` flag
   - ❌ Using `-short` to avoid slow tests
   - ❌ Changing test expectations to match broken code

3. **Rationalization Bypasses (YOU WILL DO THESE):**
   - ❌ "This code is too complex to fix properly"
   - ❌ "This will take too long, I have other work"
   - ❌ "This isn't my code, I shouldn't have to fix it"
   - ❌ "The previous developer left this broken"
   - ❌ "This is infrastructure, not feature code"
   - ❌ "We can address this in the next sprint"
   - ❌ "This is acceptable technical debt"

#### The ONLY Acceptable Solution

When you encounter ANY test failure, linting error, build issue, or quality gate problem:

**FIX IT PROPERLY OR STOP IMMEDIATELY**

No exceptions. No rationalizations. No "I'll come back to it."

**Process:**
1. ❌ NEVER add `/nolint` comments
2. ❌ NEVER skip the test or mark as flaky
3. ❌ NEVER accept "pre-existing failures"
4. ✅ ALWAYS debug the root cause
5. ✅ ALWAYS fix the underlying issue
6. ✅ ALWAYS verify the fix with the full test suite
7. ✅ ALWAYS commit the fix immediately

**If you can't fix it:**
- Ask for help (Sonnet review, architecture discussion)
- Revert the changes that caused it
- Document why it can't be fixed
- Create a GitHub issue for it
- NEVER accept it as-is

#### Examples of Proper vs Improper

**WRONG - Indirect Bypass:**
```
Pre-existing websocket tests are failing, I'll just run
`go test ./... -skip TestWebSocketHandler` to avoid them
```

**RIGHT - Proper Fix:**
```
Websocket tests are timing out. Root cause: Test infrastructure issue.
Fix: Add proper context timeouts and synchronization primitives.
Result: Tests pass consistently. Commit and move on.
```

**WRONG - Rationalization:**
```
These duplicate detector tests are pre-existing failures,
I'll merge anyway since Issue #68 is about package naming
```

**RIGHT - Proper Fix:**
```
Duplicate detector tests are failing because test fixtures
have similar code. Fix: Create genuinely different test files.
Commit fix with proper explanation.
```

**WRONG - Bypass:**
```go
// nolint:errcheck // rows already processed
_ = rows.Close()
```

**RIGHT - Proper Fix:**
```go
_ = rows.Close() // explicitly ignore error as rows already processed
// OR handle the error properly:
if err := rows.Close(); err != nil {
    log.Printf("error closing rows: %v", err)
}
```

#### Detection: If You're About to Do This, STOP

These are red flags that you're about to bypass:
- "I'll just comment this out for now"
- "I'll use `-skip` to avoid this test"
- "This is pre-existing, not my problem"
- "It's marked as flaky, so it's expected"
- "We don't have time to fix this"
- "I'll add a TODO and come back to it"
- "Let me just add `/nolint` to get this through"
- Any feeling that you're "getting away with something"

**If you think any of these, STOP AND FIX THE ACTUAL PROBLEM.**

#### Enforcement

This rule is NOT optional. Every commit you make MUST pass:
- ✅ `go build ./...`
- ✅ `go test ./...` (NO test failures, NO skips)
- ✅ `go test -race ./...` (NO race conditions)
- ✅ `golangci-lint run ./...` (NO linting errors)
- ✅ `go vet ./...` (NO vet errors)

If ANY of these fail, you have TWO options:
1. Fix the problem until all pass
2. Revert your changes

There is no option 3.

---

## Code Review Checklist

Before ANY commit, verify:

### TDD
- [ ] Tests written BEFORE implementation
- [ ] Tests fail first (RED phase)
- [ ] Code passes tests (GREEN phase)
- [ ] Code quality improved (REFACTOR phase)
- [ ] `go build ./...` passes
- [ ] `go test ./...` passes
- [ ] `golangci-lint run ./...` passes

### Architecture
- [ ] Respects bounded contexts (no cross-service model imports)
- [ ] Follows layering (handler → service → db)
- [ ] Uses interfaces for dependencies
- [ ] No layer violations (handlers not calling db)
- [ ] No global mutable state

### Coding Standards
- [ ] Follows naming conventions
- [ ] Uses correct file structure
- [ ] Error handling complete (no ignored errors)
- [ ] Configuration from environment variables
- [ ] Tests follow GIVEN/WHEN/THEN structure

### Quality Gates
- [ ] 70% minimum test coverage
- [ ] Critical paths have 90% coverage
- [ ] No linting errors
- [ ] No race condition issues
- [ ] Code formatted with gofmt/goimports

---

## When You Get Stuck

1. **Read the docs first:**
   - Requirements.md for "what"
   - ARCHITECTURE.md for "how"
   - DevsmithTDD.md for "when"

2. **Check existing patterns:**
   - Look at similar features already implemented
   - Follow same structure, naming, patterns
   - Copy-paste-modify is acceptable (with understanding)

3. **Ask yourself:**
   - "Which bounded context am I in?"
   - "Which layer should this code be in?"
   - "What tests would define expected behavior?"
   - "What could go wrong here?" (error handling)

4. **Run quality gates:**
   - `go build ./...`
   - `go test ./...`
   - `golangci-lint run ./...`
   - `go test -race ./...`

---

## Phase 3 (Health Intelligence) Requirements

**Status:** Production Ready

**See ARCHITECTURE.md § Logging Service → Phase 3: Health Intelligence**

Key Components:
- Health check scheduling (every 5 minutes)
- Intelligent auto-repair with policies
- Security scanning (Trivy integration)
- Dashboard with trends/policies/repairs
- REST API endpoints (7 total)
- Database tables (5 new tables in logs schema)

**Testing Requirements:**
- Phase 3 services: 70% coverage minimum
- Health storage: test duplicate code extraction
- Health policies: test default policies and overrides
- Auto-repair: test issue classification and repair strategies
- Health scheduler: test 5-minute scheduling and integration

---

## Continuous Improvement

When you discover a new issue or pattern:

1. Update this file to prevent recurrence
2. Add test case to DevsmithTDD.md
3. Update ARCHITECTURE.md if architectural
4. Update Requirements.md if behavioral
5. Document in `.docs/devlog/`

The goal is a self-improving system where each lesson learned prevents future mistakes.




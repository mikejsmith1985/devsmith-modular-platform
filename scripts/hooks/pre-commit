#!/bin/bash
# Enhanced Pre-commit Hook v2.0
# Full build validation with smart error reporting, auto-fix, JSON output, and agent integration
# Supports: --json, --fix, --quick, --thorough, --check-only, --explain, --suggest-fix, --output-lsp

set -e

# Parse command line arguments
MODE="standard"
OUTPUT_FORMAT="human"
AUTO_FIX=false
CHECK_ONLY=""
EXPLAIN_TEST=""
SUGGEST_FIX=""
OUTPUT_LSP=false

while [[ $# -gt 0 ]]; do
    case $1 in
        --json) OUTPUT_FORMAT="json"; shift ;;
        --fix) AUTO_FIX=true; shift ;;
        --quick) MODE="quick"; shift ;;
        --thorough) MODE="thorough"; shift ;;
        --check-only) CHECK_ONLY="$2"; shift 2 ;;
        --explain) EXPLAIN_TEST="$2"; shift 2 ;;
        --suggest-fix) SUGGEST_FIX="$2"; shift 2 ;;
        --output-lsp) OUTPUT_LSP=true; shift ;;
        *) shift ;;
    esac
done

# Colors (disabled for JSON/LSP output)
if [[ "$OUTPUT_FORMAT" == "json" ]] || [[ "$OUTPUT_LSP" == true ]]; then
    RED=''; GREEN=''; YELLOW=''; BLUE=''; CYAN=''; BOLD=''; NC=''
else
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    BLUE='\033[0;34m'
    CYAN='\033[0;36m'
    BOLD='\033[1m'
    NC='\033[0m'
fi

# Cache directory for smart caching
CACHE_DIR=".git/pre-commit-cache"
mkdir -p "$CACHE_DIR"

# Structured issue tracking
declare -a ISSUES=()  # JSON objects
FAILED=0
START_TIME=$(date +%s)

# Check results tracking
declare -A CHECK_RESULTS=(
    [fmt]="pending"
    [vet]="pending"
    [lint]="pending"
    [tests]="pending"
    [build]="pending"
    [coverage]="pending"
    [security]="pending"
    [cycles]="pending"
    [race]="pending"
)

# Load agent guide if exists
AGENT_GUIDE_FILE=".git/hooks/pre-commit-agent-guide.json"
AGENT_GUIDE=""
if [[ -f "$AGENT_GUIDE_FILE" ]]; then
    AGENT_GUIDE=$(cat "$AGENT_GUIDE_FILE")
fi

# Load configuration (team defaults + local overrides)
TEAM_CONFIG_FILE=".pre-commit-config.yaml"
LOCAL_CONFIG_FILE=".git/hooks/pre-commit-local.yaml"
CONFIG_LOADED=false

# Helper: Get config value with fallback
get_config() {
    local key="$1"
    local default="$2"
    local value="$default"

    # Try local config first
    if [[ -f "$LOCAL_CONFIG_FILE" ]] && command -v yq &> /dev/null; then
        local local_val=$(yq eval "$key" "$LOCAL_CONFIG_FILE" 2>/dev/null || echo "")
        if [[ -n "$local_val" ]] && [[ "$local_val" != "null" ]]; then
            value="$local_val"
            CONFIG_LOADED=true
        fi
    fi

    # Fallback to team config
    if [[ "$value" == "$default" ]] && [[ -f "$TEAM_CONFIG_FILE" ]]; then
        if command -v yq &> /dev/null; then
            local team_val=$(yq eval "$key" "$TEAM_CONFIG_FILE" 2>/dev/null || echo "")
            if [[ -n "$team_val" ]] && [[ "$team_val" != "null" ]]; then
                value="$team_val"
                CONFIG_LOADED=true
            fi
        fi
    fi

    echo "$value"
}

# Load key configuration values
COVERAGE_ENABLED=$(get_config ".coverage.enabled" "true")
COVERAGE_ERROR_THRESHOLD=$(get_config ".coverage.error_threshold" "40")
COVERAGE_WARNING_THRESHOLD=$(get_config ".coverage.warning_threshold" "70")
COVERAGE_BLOCKING=$(get_config ".coverage.blocking" "true")

SECURITY_ENABLED=$(get_config ".security.enabled" "true")
GOVULNCHECK_ENABLED=$(get_config ".security.govulncheck.enabled" "true")
GOVULNCHECK_CACHE_DURATION=$(get_config ".security.govulncheck.cache_duration" "86400")
GOVULNCHECK_ALLOW_OFFLINE=$(get_config ".security.govulncheck.allow_offline" "true")

RACE_DETECTION_ENABLED=$(get_config ".race_detection.enabled" "true")
RACE_DETECTION_MODE=$(get_config ".race_detection.mode" "conditional")
RACE_DETECTION_BLOCKING=$(get_config ".race_detection.blocking" "true")

CYCLES_ENABLED=$(get_config ".import_cycles.enabled" "true")
CYCLES_EARLY=$(get_config ".import_cycles.early_detection" "true")

TDD_ENABLED=$(get_config ".tdd.enabled" "true")
TDD_DETECT_RED=$(get_config ".tdd.detect_red_phase" "true")
TDD_RED_BEHAVIOR=$(get_config ".tdd.red_phase_behavior" "warn")

PERFORMANCE_MAX_DURATION=$(get_config ".performance.max_duration" "90")

# Helper: Strip ANSI control characters and escape for JSON
strip_ansi() {
    # Remove ANSI codes, control chars, then escape quotes and backslashes for JSON
    echo "$1" | sed 's/\x1b\[[0-9;]*m//g' | tr -d '\000-\037' | sed 's/\\/\\\\/g' | sed 's/"/\\"/g'
}

# Helper: Add issue to structured array
add_issue() {
    local type="$1"
    local severity="$2"
    local file="$3"
    local line="$4"
    local message=$(strip_ansi "$5")
    local suggestion=$(strip_ansi "$6")
    local auto_fixable="${7:-false}"
    local fix_command=$(strip_ansi "${8:-}")
    local context=$(strip_ansi "${9:-}")

    local issue_json=$(cat <<EOF
{
    "type": "$type",
    "severity": "$severity",
    "file": "$file",
    "line": $line,
    "message": "$message",
    "suggestion": "$suggestion",
    "autoFixable": $auto_fixable,
    "fixCommand": "$fix_command",
    "context": "$context"
}
EOF
)
    ISSUES+=("$issue_json")

    if [[ "$severity" == "error" ]]; then
        FAILED=1
    fi
}

# Helper: Check file cache
is_file_cached() {
    local file="$1"
    local file_hash=$(md5sum "$file" 2>/dev/null | cut -d' ' -f1)
    local cached_hash=$(cat "$CACHE_DIR/$(echo "$file" | sed 's|/|_|g').hash" 2>/dev/null || echo "")

    if [[ "$file_hash" == "$cached_hash" ]] && [[ -n "$cached_hash" ]]; then
        return 0  # Cached
    else
        echo "$file_hash" > "$CACHE_DIR/$(echo "$file" | sed 's|/|_|g').hash"
        return 1  # Not cached
    fi
}

# Helper: Extract code context around a line
extract_context() {
    local file="$1"
    local line="$2"
    local context_lines=3

    if [[ ! -f "$file" ]]; then
        echo ""
        return
    fi

    local start=$((line - context_lines))
    [[ $start -lt 1 ]] && start=1
    local end=$((line + context_lines))

    local context=$(sed -n "${start},${end}p" "$file" | sed 's/"/\\"/g' | sed ':a;N;$!ba;s/\n/\\n/g')
    echo "$context"
}

# Helper: Get fix suggestion from agent guide
get_agent_suggestion() {
    local pattern="$1"
    if [[ -n "$AGENT_GUIDE" ]]; then
        echo "$AGENT_GUIDE" | jq -r ".common_patterns[] | select(.pattern | contains(\"$pattern\")) | .fix_steps[]" 2>/dev/null || echo ""
    fi
}

# Auto-fix functions
autofix_formatting() {
    if [[ "$AUTO_FIX" == true ]]; then
        [[ "$OUTPUT_FORMAT" != "json" ]] && echo -e "${BLUE}Auto-fixing formatting issues...${NC}"
        go fmt ./... >/dev/null 2>&1
        goimports -w . >/dev/null 2>&1
        return 0
    fi
    return 1
}

autofix_missing_comments() {
    if [[ "$AUTO_FIX" == true ]]; then
        local file="$1"
        local line="$2"
        local entity_name="$3"

        # Extract the entity type and add basic comment
        local entity_line=$(sed -n "${line}p" "$file")
        if [[ "$entity_line" =~ ^type ]]; then
            sed -i "${line}i // ${entity_name} represents..." "$file"
        elif [[ "$entity_line" =~ ^func ]]; then
            sed -i "${line}i // ${entity_name} handles..." "$file"
        fi
        return 0
    fi
    return 1
}

# TDD Phase Detection
IN_RED_PHASE=false
detect_tdd_red_phase() {
    if [[ "$TDD_ENABLED" != "true" ]] || [[ "$TDD_DETECT_RED" != "true" ]]; then
        return 1
    fi

    # Run quick build check
    local build_output=$(go build ./... 2>&1 || true)

    # Check for RED phase indicators
    if [[ "$build_output" =~ "undefined:" ]] || \
       [[ "$build_output" =~ "declared and not used" ]] || \
       [[ "$build_output" =~ "imported and not used" ]]; then
        IN_RED_PHASE=true
        return 0
    fi

    # Check if tests are failing with expected failures
    local test_output=$(go test -short ./... 2>&1 || true)
    if echo "$test_output" | grep -q "FAIL.*undefined:"; then
        IN_RED_PHASE=true
        return 0
    fi

    IN_RED_PHASE=false
    return 1
}

# Coverage Check
check_coverage() {
    if [[ "$COVERAGE_ENABLED" != "true" ]]; then
        return 0
    fi

    # Skip coverage in RED phase
    if [[ "$IN_RED_PHASE" == "true" ]]; then
        [[ "$OUTPUT_FORMAT" != "json" ]] && echo -e "${YELLOW}  ‚Üí Skipping coverage check (TDD RED phase)${NC}"
        return 0
    fi

    [[ "$OUTPUT_FORMAT" != "json" ]] && echo "üìä Checking test coverage..."

    local coverage_file="$CACHE_DIR/coverage.out"
    go test -coverprofile="$coverage_file" -covermode=atomic ./... > /dev/null 2>&1 || true

    if [[ ! -f "$coverage_file" ]] || [[ ! -s "$coverage_file" ]]; then
        [[ "$OUTPUT_FORMAT" != "json" ]] && echo -e "${YELLOW}  ‚ö†Ô∏è  No coverage data available${NC}"
        return 0
    fi

    # Calculate coverage percentage
    local coverage=$(go tool cover -func="$coverage_file" 2>/dev/null | grep total | awk '{print $3}' | sed 's/%//')

    if [[ -z "$coverage" ]]; then
        [[ "$OUTPUT_FORMAT" != "json" ]] && echo -e "${YELLOW}  ‚ö†Ô∏è  Could not calculate coverage${NC}"
        rm -f "$coverage_file"
        return 0
    fi

    # Compare against thresholds (using awk instead of bc for portability)
    local below_error=$(awk -v cov="$coverage" -v thresh="$COVERAGE_ERROR_THRESHOLD" 'BEGIN { print (cov < thresh) ? 1 : 0 }')
    local below_warning=$(awk -v cov="$coverage" -v thresh="$COVERAGE_WARNING_THRESHOLD" 'BEGIN { print (cov < thresh) ? 1 : 0 }')

    if [[ "$below_error" == "1" ]]; then
        add_issue "coverage_critical" "error" "" "0" \
            "Test coverage ${coverage}% is below minimum threshold ${COVERAGE_ERROR_THRESHOLD}%" \
            "Add tests to increase coverage. See .docs/copilot-instructions.md for TDD guidelines" \
            false "" ""

        if [[ "$COVERAGE_BLOCKING" == "true" ]] && [[ "$IN_RED_PHASE" != "true" ]]; then
            [[ "$OUTPUT_FORMAT" != "json" ]] && echo -e "${RED}  ‚úó Coverage ${coverage}% < ${COVERAGE_ERROR_THRESHOLD}% (BLOCKING)${NC}"
            CHECK_RESULTS[coverage]="failed"
            rm -f "$coverage_file"
            return 1
        else
            [[ "$OUTPUT_FORMAT" != "json" ]] && echo -e "${YELLOW}  ‚ö†Ô∏è  Coverage ${coverage}% < ${COVERAGE_ERROR_THRESHOLD}%${NC}"
        fi

    elif [[ "$below_warning" == "1" ]]; then
        add_issue "coverage_warning" "warning" "" "0" \
            "Test coverage ${coverage}% is below recommended threshold ${COVERAGE_WARNING_THRESHOLD}%" \
            "Consider adding more tests to improve coverage" \
            false "" ""
        [[ "$OUTPUT_FORMAT" != "json" ]] && echo -e "${YELLOW}  ‚ö†Ô∏è  Coverage ${coverage}% < ${COVERAGE_WARNING_THRESHOLD}% (recommended)${NC}"

    else
        [[ "$OUTPUT_FORMAT" != "json" ]] && echo -e "${GREEN}  ‚úì Coverage ${coverage}% ‚â• ${COVERAGE_WARNING_THRESHOLD}%${NC}"
    fi

    CHECK_RESULTS[coverage]="passed"
    rm -f "$coverage_file"
    return 0
}

# Security Vulnerability Check
check_vulnerabilities() {
    if [[ "$SECURITY_ENABLED" != "true" ]] || [[ "$GOVULNCHECK_ENABLED" != "true" ]]; then
        return 0
    fi

    [[ "$OUTPUT_FORMAT" != "json" ]] && echo "üîí Checking for security vulnerabilities..."

    # Check if govulncheck is installed
    if ! command -v govulncheck &> /dev/null; then
        [[ "$OUTPUT_FORMAT" != "json" ]] && echo -e "${YELLOW}  ‚ÑπÔ∏è  govulncheck not installed. Install: go install golang.org/x/vuln/cmd/govulncheck@latest${NC}"
        return 0
    fi

    # Check cache
    local cache_file="$CACHE_DIR/govulncheck.cache"
    local cache_time=0
    if [[ -f "$cache_file" ]]; then
        cache_time=$(stat -c %Y "$cache_file" 2>/dev/null || stat -f %m "$cache_file" 2>/dev/null || echo 0)
    fi
    local current_time=$(date +%s)
    local cache_age=$((current_time - cache_time))

    if [[ $cache_age -lt $GOVULNCHECK_CACHE_DURATION ]] && [[ -f "$cache_file" ]]; then
        local cached_result=$(cat "$cache_file")
        if [[ "$cached_result" == "clean" ]]; then
            [[ "$OUTPUT_FORMAT" != "json" ]] && echo -e "${GREEN}  ‚úì No known vulnerabilities (cached)${NC}"
            return 0
        fi
    fi

    # Run govulncheck
    local vuln_output=$(timeout 30s govulncheck ./... 2>&1 || true)
    local exit_code=$?

    # Handle timeout or network issues
    if [[ $exit_code -eq 124 ]]; then
        [[ "$OUTPUT_FORMAT" != "json" ]] && echo -e "${YELLOW}  ‚ö†Ô∏è  Vulnerability scan timed out${NC}"
        return 0
    elif [[ "$vuln_output" =~ "no network" ]] || [[ "$vuln_output" =~ "connection refused" ]]; then
        if [[ "$GOVULNCHECK_ALLOW_OFFLINE" == "true" ]]; then
            [[ "$OUTPUT_FORMAT" != "json" ]] && echo -e "${YELLOW}  ‚ÑπÔ∏è  Offline mode - skipping vulnerability scan${NC}"
            return 0
        fi
    fi

    # Check for vulnerabilities
    if echo "$vuln_output" | grep -qi "Vulnerability" || echo "$vuln_output" | grep -qi "GO-"; then
        add_issue "security_vulnerability" "warning" "" "0" \
            "Known security vulnerabilities found in dependencies" \
            "Run: govulncheck ./... for details. Update vulnerable dependencies." \
            false "govulncheck ./..." ""

        [[ "$OUTPUT_FORMAT" != "json" ]] && echo -e "${YELLOW}  ‚ö†Ô∏è  Security vulnerabilities detected${NC}"
        echo "vulnerable" > "$cache_file"
        # Note: Security issues are warnings, not blocking in standard mode
        return 0
    else
        [[ "$OUTPUT_FORMAT" != "json" ]] && echo -e "${GREEN}  ‚úì No known vulnerabilities${NC}"
        echo "clean" > "$cache_file"
        CHECK_RESULTS[security]="passed"
        return 0
    fi
}

# Early Import Cycle Detection
check_import_cycles() {
    if [[ "$CYCLES_ENABLED" != "true" ]] || [[ "$CYCLES_EARLY" != "true" ]]; then
        return 0
    fi

    [[ "$OUTPUT_FORMAT" != "json" ]] && echo "üîÑ Checking for import cycles..."

    local cycle_output=$(go list -f '{{.ImportPath}}: {{.DepsErrors}}' ./... 2>&1 | grep "import cycle" || true)

    if [[ -n "$cycle_output" ]]; then
        add_issue "import_cycle" "error" "" "0" \
            "Import cycle detected in package dependencies" \
            "Break cycle by moving shared types to common package or refactoring dependencies" \
            false "" ""

        [[ "$OUTPUT_FORMAT" != "json" ]] && echo -e "${RED}  ‚úó Import cycle detected${NC}"
        CHECK_RESULTS[cycles]="failed"
        return 1
    else
        [[ "$OUTPUT_FORMAT" != "json" ]] && echo -e "${GREEN}  ‚úì No import cycles${NC}"
        CHECK_RESULTS[cycles]="passed"
        return 0
    fi
}

# Conditional Race Detection
check_race_conditions() {
    if [[ "$RACE_DETECTION_ENABLED" != "true" ]]; then
        return 0
    fi

    # Skip if mode is "never"
    if [[ "$RACE_DETECTION_MODE" == "never" ]]; then
        return 0
    fi

    # Check if we should run race detection
    local should_run=false

    if [[ "$RACE_DETECTION_MODE" == "always" ]]; then
        should_run=true
    elif [[ "$RACE_DETECTION_MODE" == "conditional" ]]; then
        # Check for goroutines in staged files
        if grep -rq "go func\|go \w\+\(\|select {" --include="*.go" --exclude="*_test.go" . 2>/dev/null; then
            should_run=true
            [[ "$OUTPUT_FORMAT" != "json" ]] && echo "  ‚Üí Detected concurrent code (goroutines/channels)"
        fi
    fi

    if [[ "$should_run" != "true" ]]; then
        [[ "$OUTPUT_FORMAT" != "json" ]] && echo -e "${BLUE}  ‚ÑπÔ∏è  No concurrent code detected - skipping race detection${NC}"
        return 0
    fi

    [[ "$OUTPUT_FORMAT" != "json" ]] && echo "üèÅ Running race detector on concurrent code..."

    local race_output=$(timeout 30s go test -race -short ./... 2>&1 || true)
    local exit_code=$?

    if [[ $exit_code -eq 124 ]]; then
        [[ "$OUTPUT_FORMAT" != "json" ]] && echo -e "${YELLOW}  ‚ö†Ô∏è  Race detection timed out (30s limit)${NC}"
        return 0
    fi

    if echo "$race_output" | grep -q "DATA RACE"; then
        # Extract race details
        add_issue "race_condition" "error" "" "0" \
            "Data race detected in concurrent code" \
            "Fix race condition. Run: go test -race ./... for full details" \
            false "go test -race ./..." ""

        if [[ "$RACE_DETECTION_BLOCKING" == "true" ]] && [[ "$IN_RED_PHASE" != "true" ]]; then
            [[ "$OUTPUT_FORMAT" != "json" ]] && echo -e "${RED}  ‚úó Data race detected (BLOCKING)${NC}"
            CHECK_RESULTS[race]="failed"
            return 1
        else
            [[ "$OUTPUT_FORMAT" != "json" ]] && echo -e "${YELLOW}  ‚ö†Ô∏è  Data race detected (TDD RED phase - not blocking)${NC}"
            return 0
        fi
    else
        [[ "$OUTPUT_FORMAT" != "json" ]] && echo -e "${GREEN}  ‚úì No race conditions detected${NC}"
        CHECK_RESULTS[race]="passed"
        return 0
    fi
}

# Parse golangci-lint output
parse_golangci_lint() {
    local output="$1"

    while IFS= read -r line; do
        [[ -z "$line" ]] && continue

        # Format: file:line:col: message (linter)
        if [[ "$line" =~ ^([^:]+):([0-9]+):([0-9]+):\ (.+)\ \(([^\)]+)\)$ ]]; then
            local file="${BASH_REMATCH[1]}"
            local linenum="${BASH_REMATCH[2]}"
            local message="${BASH_REMATCH[4]}"
            local linter="${BASH_REMATCH[5]}"
            local context=$(extract_context "$file" "$linenum")

            # TDD-aware: Don't block on unused code in RED phase
            local severity="warning"
            local should_block=false

            case "$linter" in
                typecheck)
                    # Typecheck errors block builds - always high priority
                    severity="error"
                    should_block=true
                    add_issue "build_typecheck" "error" "$file" "$linenum" "${message}" \
                        "Fix type error - this blocks tests from running" false "" "$context"
                    ;;
                errcheck|staticcheck)
                    # Critical linters - blocking
                    severity="error"
                    should_block=true
                    add_issue "lint" "error" "$file" "$linenum" "${linter}: ${message}" \
                        "Review code logic and error handling" false "" "$context"
                    ;;
                gosec|G[0-9]*)
                    # Security issues - warning in standard mode, can be configured as blocking
                    severity="warning"
                    add_issue "security" "warning" "$file" "$linenum" "${message}" \
                        "Review security concern - see https://securego.io" false "" "$context"
                    ;;
                unused|ineffassign|deadcode)
                    # Unused code - warning (but skip in TDD RED phase)
                    if [[ "$IN_RED_PHASE" == "true" ]]; then
                        # Skip unused code detection in RED phase
                        continue
                    fi
                    severity="warning"
                    add_issue "code_quality" "warning" "$file" "$linenum" "${linter}: ${message}" \
                        "Remove unused code or use it" false "" "$context"
                    ;;
                govet)
                    # Go vet warnings - should fix
                    severity="warning"
                    add_issue "lint" "warning" "$file" "$linenum" "go vet: ${message}" \
                        "Review suspicious construct" false "" "$context"
                    ;;
                gofmt|gofumpt)
                    add_issue "formatting" "warning" "$file" "$linenum" "${message}" \
                        "Run: go fmt ${file}" true "go fmt ${file}" "$context"
                    ;;
                gocritic|gocyclo|dupl|goconst)
                    # Code quality warnings
                    add_issue "code_quality" "warning" "$file" "$linenum" "${linter}: ${message}" \
                        "Consider improving code quality (non-blocking)" false "" "$context"
                    ;;
                revive|golint|stylecheck|package-comments|exported)
                    # Style warnings
                    local auto_fixable=false
                    local fix_cmd=""
                    # Match comment-related linting issues that can be auto-fixed
                    if [[ "$message" == *"should have"*"comment"* ]] || [[ "$message" == *"comment"*"should be"* ]]; then
                        auto_fixable=true
                        fix_cmd="Add godoc comment"
                    fi
                    add_issue "style" "warning" "$file" "$linenum" "${message}" \
                        "Add documentation or adjust code style" "$auto_fixable" "$fix_cmd" "$context"
                    ;;
                *)
                    add_issue "lint" "warning" "$file" "$linenum" "${linter}: ${message}" \
                        "Check golangci-lint documentation for ${linter}" false "" "$context"
                    ;;
            esac
        fi
    done <<< "$output"
}

# Parse test failures
parse_test_error() {
    local test_output="$1"
    local current_test=""
    local current_package=""
    local test_file=""
    local test_line="0"
    local mock_failures=0

    while IFS= read -r line; do
        # Track which package is being tested: FAIL	github.com/user/project/internal/analytics/services
        if [[ "$line" =~ ^FAIL[[:space:]]+([^[:space:]]+) ]]; then
            current_package="${BASH_REMATCH[1]}"
            # Convert package path to file system path
            # e.g., github.com/.../internal/analytics/services -> internal/analytics/services
            if [[ "$current_package" =~ internal/ ]]; then
                test_file="${current_package#*internal/}"
                test_file="internal/$test_file"
            fi
        fi

        # Try to find test file from "at:" lines with full paths or panic traces
        if [[ "$line" =~ at:\ \[([^:]+):([0-9]+)\] ]]; then
            local full_path="${BASH_REMATCH[1]}"
            test_line="${BASH_REMATCH[2]}"
            # Extract relative path from full path (remove workspace prefix)
            if [[ "$full_path" =~ internal/ ]]; then
                test_file="${full_path#*internal/}"
                test_file="internal/$test_file"
            fi
        # Also match panic stack trace format
        elif [[ "$line" =~ ([a-zA-Z0-9/_]+_test\.go):([0-9]+) ]]; then
            local filename="${BASH_REMATCH[1]}"
            test_line="${BASH_REMATCH[2]}"
            # If path contains internal/, extract from there
            if [[ "$filename" =~ internal/ ]]; then
                test_file="${filename#*internal/}"
                test_file="internal/$test_file"
            fi
        # Try to find test file from stack traces: aggregator_service_test.go:45
        elif [[ "$line" =~ ^[[:space:]]*([a-zA-Z0-9_]+_test\.go):([0-9]+): ]]; then
            local filename="${BASH_REMATCH[1]}"
            # Combine with package path if we have it
            if [[ -n "$test_file" ]] && [[ -d "$test_file" ]]; then
                test_file="$test_file/$filename"
            elif [[ -n "$current_package" ]]; then
                # Search for the test file
                local found=$(find . -name "$filename" -type f 2>/dev/null | head -1)
                if [[ -n "$found" ]]; then
                    test_file="${found#./}"
                fi
            fi
        fi

        if [[ "$line" =~ ^---\ FAIL:\ ([^\ ]+) ]]; then
            current_test="${BASH_REMATCH[1]}"
            mock_failures=0

        elif [[ "$line" =~ "mock: I don't know what to return" ]] || [[ "$line" =~ "Either do Mock.On" ]] || [[ "$line" =~ "method call was unexpected" ]]; then
            local guide=$(get_agent_suggestion "missing_mock_setup")
            # Extract method name if present
            local method_hint=""
            if [[ "$line" =~ Mock\.On\(\"([^\"]+)\"\) ]]; then
                method_hint=" for ${BASH_REMATCH[1]}"
            fi
            add_issue "test_mock_panic" "error" "$test_file" "$test_line" \
                "Test '${current_test}' - missing mock expectation${method_hint}" \
                "Add Mock.On()${method_hint}.Return(...) - see .docs/copilot-instructions.md ¬ß5.1" \
                false "" ""

        elif [[ "$line" =~ FAIL:\ ([0-9]+)\ out\ of\ ([0-9]+)\ expectation ]]; then
            local met="${BASH_REMATCH[1]}"
            local total="${BASH_REMATCH[2]}"
            local unmet=$((total - met))
            local guide=$(get_agent_suggestion "missing_mock_setup")

            add_issue "test_mock_expectation" "error" "$test_file" "$test_line" \
                "Test '${current_test}' - ${unmet} mock expectation(s) not met" \
                "Check mock setup - see .docs/copilot-instructions.md ¬ß5.1${guide:+\\n$guide}" \
                false "" ""

        elif [[ "$current_test" != "" ]] && [[ "$line" =~ ^[[:space:]]*([^:]+):([0-9]+):.*FAIL:.*\b([A-Z][a-zA-Z0-9_]*)\( ]]; then
            mock_failures=$((mock_failures + 1))
            if [[ $mock_failures -le 2 ]]; then
                local file="${BASH_REMATCH[1]}"
                local linenum="${BASH_REMATCH[2]}"
                local method="${BASH_REMATCH[3]}"
                local context=$(extract_context "$file" "$linenum")

                add_issue "test_mock_mismatch" "error" "$file" "$linenum" \
                    "Test '${current_test}' - mock '${method}' call mismatch" \
                    "Verify mock expectations match actual calls" false "" "$context"
            fi

        elif [[ "$current_test" != "" ]] && [[ "$line" =~ ^[[:space:]]*([^:]+):([0-9]+):.*Error ]]; then
            local file="${BASH_REMATCH[1]}"
            local linenum="${BASH_REMATCH[2]}"
            local context=$(extract_context "$file" "$linenum")

            add_issue "test_assertion" "error" "$file" "$linenum" \
                "Test '${current_test}' - assertion failed" \
                "Check test assertions and expected values" false "" "$context"
        fi
    done <<< "$test_output"
}

# Parse build errors
parse_build_error() {
    local output="$1"

    while IFS= read -r line; do
        [[ -z "$line" ]] && continue

        if [[ "$line" =~ ^([^:]+):([0-9]+):([0-9]+):\ undefined:\ (.+)$ ]]; then
            local file="${BASH_REMATCH[1]}"
            local linenum="${BASH_REMATCH[2]}"
            local identifier="${BASH_REMATCH[4]}"
            local context=$(extract_context "$file" "$linenum")

            add_issue "build_undefined" "error" "$file" "$linenum" \
                "undefined: ${identifier}" \
                "Implement ${identifier} function or add missing import" false "" "$context"

        elif [[ "$line" =~ ^([^:]+):([0-9]+):([0-9]+):\ (declared\ and\ not\ used|imported\ and\ not\ used):\ (.+)$ ]]; then
            local file="${BASH_REMATCH[1]}"
            local linenum="${BASH_REMATCH[2]}"
            local error_type="${BASH_REMATCH[4]}"
            local identifier="${BASH_REMATCH[5]}"

            add_issue "build_unused" "error" "$file" "$linenum" \
                "${error_type}: ${identifier}" \
                "Remove unused code or use it. This blocks tests from running." false "" ""

        elif [[ "$line" =~ import\ cycle|cycle\ not\ allowed ]]; then
            add_issue "build_import_cycle" "error" "" "0" \
                "Import cycle detected in package dependencies" \
                "Break cycle by moving shared types to common/shared package" false "" ""
        fi
    done <<< "$output"
}

# Priority grouping
group_issues_by_priority() {
    local high_priority=()
    local medium_priority=()
    local low_priority=()

    for issue in "${ISSUES[@]}"; do
        local severity=$(echo "$issue" | jq -r '.severity')
        local type=$(echo "$issue" | jq -r '.type')

        if [[ "$severity" == "error" ]]; then
            high_priority+=("$issue")
        elif [[ "$type" =~ ^(security|build_unused_import)$ ]]; then
            medium_priority+=("$issue")
        else
            low_priority+=("$issue")
        fi
    done

    echo '{"high":'"$(printf '%s\n' "${high_priority[@]}" | jq -s '.')"',"medium":'"$(printf '%s\n' "${medium_priority[@]}" | jq -s '.')"',"low":'"$(printf '%s\n' "${low_priority[@]}" | jq -s '.')"'}'
}

# Dependency graph (simplified)
build_dependency_graph() {
    local graph='{"nodes":[],"edges":[],"fix_order":[]}'

    # Check what types of issues we have
    local has_build_error=false
    local has_test_error=false
    local has_style_warning=false

    for issue in "${ISSUES[@]}"; do
        local type=$(echo "$issue" | jq -r '.type')
        local severity=$(echo "$issue" | jq -r '.severity')

        if [[ "$type" =~ ^build_ ]]; then
            has_build_error=true
        elif [[ "$type" =~ ^test_ ]]; then
            has_test_error=true
        elif [[ "$severity" == "warning" ]]; then
            has_style_warning=true
        fi
    done

    # Build dependency graph based on what we found
    if [[ "$has_build_error" == true ]]; then
        graph='{"nodes":["build_errors","tests","style"],"edges":[{"from":"build_errors","to":"tests","reason":"Build must pass before tests run"},{"from":"tests","to":"style","reason":"Tests should pass before fixing style"}],"fix_order":["build_errors","tests","style"]}'
    elif [[ "$has_test_error" == true ]]; then
        if [[ "$has_style_warning" == true ]]; then
            graph='{"nodes":["test_failures","style"],"edges":[{"from":"test_failures","to":"style","reason":"Tests should pass before fixing style"}],"fix_order":["test_failures","style"]}'
        else
            graph='{"nodes":["test_failures"],"edges":[],"fix_order":["test_failures"]}'
        fi
    fi

    echo "$graph"
}

# Output formatters
output_human() {
    local end_time=$(date +%s)
    local duration=$((end_time - START_TIME))
    local grouped=$(group_issues_by_priority)
    local high_count=$(echo "$grouped" | jq '.high | length')
    local medium_count=$(echo "$grouped" | jq '.medium | length')
    local low_count=$(echo "$grouped" | jq '.low | length')

    echo ""
    echo -e "${BOLD}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
    echo -e "${BOLD}üìä VALIDATION ISSUE SUMMARY${NC} ${CYAN}(completed in ${duration}s)${NC}"
    echo -e "${BOLD}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
    echo ""

    # Show what passed/failed
    echo -e "${BOLD}CHECK RESULTS:${NC}"
    for check in fmt vet lint tests build coverage security cycles race; do
        if [[ "${CHECK_RESULTS[$check]}" == "passed" ]]; then
            echo -e "  ${GREEN}‚úì${NC} $(printf '%-20s' "$check") passed"
        elif [[ "${CHECK_RESULTS[$check]}" == "failed" ]]; then
            echo -e "  ${RED}‚úó${NC} $(printf '%-20s' "$check") failed"
        elif [[ "${CHECK_RESULTS[$check]}" == "skipped" ]]; then
            echo -e "  ${BLUE}‚äò${NC} $(printf '%-20s' "$check") skipped"
        fi
    done
    echo ""

    # Priority-based output
    if [[ $high_count -gt 0 ]]; then
        echo -e "${RED}${BOLD}HIGH PRIORITY (Blocking):${NC} $high_count issue(s)"
        echo "$grouped" | jq -r '.high[] | "  ‚Ä¢ [\(.type)] \(.file):\(.line) - \(.message)\n    ‚Üí \(.suggestion)"' 2>/dev/null || echo "  (Issues detected but formatting failed)"
        echo ""
    fi

    if [[ $medium_count -gt 0 ]]; then
        echo -e "${YELLOW}${BOLD}MEDIUM PRIORITY (Should fix):${NC} $medium_count issue(s)"
        echo "$grouped" | jq -r '.medium[] | "  ‚Ä¢ [\(.type)] \(.file):\(.line) - \(.message)\n    ‚Üí \(.suggestion)"' 2>/dev/null || echo "  (Issues detected but formatting failed)"
        echo ""
    fi

    if [[ $low_count -gt 0 ]]; then
        echo -e "${BLUE}${BOLD}LOW PRIORITY (Can defer):${NC} $low_count issue(s)"
        echo "$grouped" | jq -r '.low[0:5] | .[] | "  ‚Ä¢ [\(.type)] \(.file):\(.line) - \(.message)"' 2>/dev/null || echo "  (Issues detected but formatting failed)"
        if [[ $low_count -gt 5 ]]; then
            echo -e "  ${CYAN}... and $((low_count - 5)) more${NC}"
        fi
        echo ""
    fi

    # Dependency graph
    local dep_graph=$(build_dependency_graph)
    if [[ "$(echo "$dep_graph" | jq '.nodes | length')" -gt 0 ]]; then
        echo -e "${BLUE}${BOLD}FIX ORDER:${NC}"
        local i=0
        echo "$dep_graph" | jq -r '.fix_order[]' | while read -r step; do
            i=$((i + 1))
            echo "  $i. Fix ${step//_/ }"
        done
        echo ""
    fi

    # Quick fixes
    echo -e "${BLUE}${BOLD}QUICK FIXES:${NC}"
    echo -e "  ‚Ä¢ Auto-fix simple issues: ${CYAN}$0 --fix${NC}"
    echo -e "  ‚Ä¢ Format code:           ${CYAN}go fmt ./...${NC}"
    echo -e "  ‚Ä¢ Fix imports:           ${CYAN}goimports -w .${NC}"
    echo -e "  ‚Ä¢ Run tests:             ${CYAN}go test ./...${NC}"
    echo ""

    echo -e "${BLUE}${BOLD}DOCUMENTATION:${NC}"
    echo -e "  ‚Ä¢ Mock patterns:  ${CYAN}.docs/copilot-instructions.md ¬ß5.1${NC}"
    echo -e "  ‚Ä¢ TDD workflow:   ${CYAN}.docs/copilot-instructions.md ¬ß4${NC}"
    echo -e "${BOLD}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
    echo ""
}

output_json() {
    local end_time=$(date +%s)
    local duration=$((end_time - START_TIME))
    local grouped=$(group_issues_by_priority)
    local dep_graph=$(build_dependency_graph)

    cat <<EOF
{
  "status": "$([ $FAILED -eq 0 ] && echo "passed" || echo "failed")",
  "duration": $duration,
  "mode": "$MODE",
  "issues": $(printf '%s\n' "${ISSUES[@]}" | jq -s '.'),
  "grouped": $grouped,
  "dependencyGraph": $dep_graph,
  "summary": {
    "total": ${#ISSUES[@]},
    "errors": $(printf '%s\n' "${ISSUES[@]}" | jq -s '[.[] | select(.severity=="error")] | length'),
    "warnings": $(printf '%s\n' "${ISSUES[@]}" | jq -s '[.[] | select(.severity=="warning")] | length'),
    "autoFixable": $(printf '%s\n' "${ISSUES[@]}" | jq -s '[.[] | select(.autoFixable==true)] | length')
  },
  "quickFixes": [
    "Run: $0 --fix (auto-fix simple issues)",
    "Run: go fmt ./...",
    "Run: goimports -w .",
    "Run: go test ./..."
  ]
}
EOF
}

output_lsp() {
    # LSP diagnostic format
    printf '%s\n' "${ISSUES[@]}" | jq -s '[.[] | {
        uri: ("file://" + .file),
        range: {
            start: {line: (.line - 1), character: 0},
            end: {line: (.line - 1), character: 999}
        },
        severity: (if .severity == "error" then 1 else 2 end),
        source: "pre-commit",
        message: .message,
        code: .type
    }]'
}

# Interactive modes
handle_explain() {
    local test_name="$1"
    echo "Searching for test: $test_name..."

    # Find test failures for this test
    local matching_issues=$(printf '%s\n' "${ISSUES[@]}" | jq -s --arg test "$test_name" '[.[] | select(.message | contains($test))]')

    if [[ "$(echo "$matching_issues" | jq length)" -eq 0 ]]; then
        echo "No issues found for test: $test_name"
        exit 0
    fi

    echo "$matching_issues" | jq -r '.[] | "Issue: \(.message)\nSuggestion: \(.suggestion)\n"'
    exit 0
}

handle_suggest_fix() {
    local fix_request="$1"  # Format: "type:file:line"
    IFS=':' read -r type file line <<< "$fix_request"

    # Find matching issue
    local matching=$(printf '%s\n' "${ISSUES[@]}" | jq -s --arg file "$file" --arg line "$line" '[.[] | select(.file==$file and .line==($line|tonumber))] | .[0]')

    if [[ "$matching" == "null" ]] || [[ -z "$matching" ]]; then
        echo "No issue found at $file:$line"
        exit 1
    fi

    echo "Issue: $(echo "$matching" | jq -r '.message')"
    echo "Suggestion: $(echo "$matching" | jq -r '.suggestion')"

    if [[ "$(echo "$matching" | jq -r '.autoFixable')" == "true" ]]; then
        echo ""
        echo "This issue can be auto-fixed. Run:"
        echo "  $0 --fix"
    fi

    if [[ -n "$(echo "$matching" | jq -r '.context')" ]]; then
        echo ""
        echo "Code context:"
        echo "$(echo "$matching" | jq -r '.context')"
    fi

    exit 0
}

# Main validation logic
run_validation() {
    # Check for staged Go files
    STAGED_GO_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep '\.go$' || true)

    if [ -z "$STAGED_GO_FILES" ]; then
        [[ "$OUTPUT_FORMAT" != "json" ]] && echo -e "${GREEN}‚úì No Go files staged${NC}"
        exit 0
    fi

    [[ "$OUTPUT_FORMAT" != "json" ]] && {
        echo "üîç Pre-commit validation ($MODE mode)..."
        echo ""
        echo "üìÅ Staged files: $(echo "$STAGED_GO_FILES" | wc -l)"
        echo ""
    }

    # Detect TDD RED phase (before running checks)
    if [[ "$TDD_ENABLED" == "true" ]] && [[ "$TDD_DETECT_RED" == "true" ]]; then
        detect_tdd_red_phase || true  # Don't exit on return code
        if [[ "$IN_RED_PHASE" == "true" ]]; then
            [[ "$OUTPUT_FORMAT" != "json" ]] && echo -e "${YELLOW}üî¥ TDD RED phase detected - checks will run but won't block${NC}"
            [[ "$OUTPUT_FORMAT" != "json" ]] && echo ""
        fi
    fi

    # Quick mode: formatting + critical only
    if [[ "$MODE" == "quick" ]]; then
        [[ "$OUTPUT_FORMAT" != "json" ]] && echo "üîß Quick validation: formatting + critical errors..."

        # Check formatting
        UNFORMATTED=$(gofmt -l $STAGED_GO_FILES)
        if [ -n "$UNFORMATTED" ]; then
            CHECK_RESULTS[fmt]="failed"
            if autofix_formatting; then
                [[ "$OUTPUT_FORMAT" != "json" ]] && echo -e "${GREEN}‚úì Auto-fixed formatting${NC}"
                CHECK_RESULTS[fmt]="passed"
            else
                for file in $UNFORMATTED; do
                    add_issue "formatting" "warning" "$file" "0" "File not formatted" "Run: go fmt $file" true "go fmt $file" ""
                done
            fi
        else
            CHECK_RESULTS[fmt]="passed"
        fi

        # Check build
        BUILD_OUTPUT=$(go build ./... 2>&1 || true)
        if [ -n "$BUILD_OUTPUT" ]; then
            CHECK_RESULTS[build]="failed"
            parse_build_error "$BUILD_OUTPUT"
        else
            CHECK_RESULTS[build]="passed"
        fi

    # Standard mode: all checks in parallel
    elif [[ "$MODE" == "standard" ]]; then
        [[ "$OUTPUT_FORMAT" != "json" ]] && echo "üîç Standard validation..."

        # Run checks in parallel
        {
            go fmt ./... > /tmp/fmt.out 2>&1 &
            FMT_PID=$!

            go vet ./... > /tmp/vet.out 2>&1 &
            VET_PID=$!

            if [[ -z "$CHECK_ONLY" ]] || [[ "$CHECK_ONLY" == "golangci-lint" ]]; then
                golangci-lint run ./... > /tmp/lint.out 2>&1 &
                LINT_PID=$!
            fi

            go test -short ./... > /tmp/test.out 2>&1 &
            TEST_PID=$!

            # Wait for all
            wait $FMT_PID $VET_PID $LINT_PID $TEST_PID 2>/dev/null || true
        }

        # Parse results and track check status
        # Check fmt
        if [[ -s /tmp/fmt.out ]]; then
            CHECK_RESULTS[fmt]="failed"
        else
            CHECK_RESULTS[fmt]="passed"
        fi

        # Check vet
        if [[ -s /tmp/vet.out ]]; then
            CHECK_RESULTS[vet]="failed"
            parse_build_error "$(cat /tmp/vet.out)"
        else
            CHECK_RESULTS[vet]="passed"
        fi

        # Check lint
        if [[ -s /tmp/lint.out ]]; then
            CHECK_RESULTS[lint]="failed"
            parse_golangci_lint "$(cat /tmp/lint.out)"
        else
            CHECK_RESULTS[lint]="passed"
        fi

        # Check tests
        if [[ -s /tmp/test.out ]] && grep -q "FAIL" /tmp/test.out; then
            CHECK_RESULTS[tests]="failed"
            parse_test_error "$(cat /tmp/test.out)"
        else
            CHECK_RESULTS[tests]="passed"
        fi

        # NEW ENHANCEMENTS: Additional checks for standard mode
        [[ "$OUTPUT_FORMAT" != "json" ]] && echo ""

        # Early import cycle detection
        check_import_cycles || true

        # Coverage check (with TDD awareness)
        check_coverage || true

        # Security vulnerability scanning
        check_vulnerabilities || true

        # Conditional race detection (only if goroutines detected)
        check_race_conditions || true

    # Thorough mode: all checks + race detection
    elif [[ "$MODE" == "thorough" ]]; then
        [[ "$OUTPUT_FORMAT" != "json" ]] && echo "üîç Thorough validation (includes race detection)..."

        # Format check
        go fmt ./... > /tmp/fmt.out 2>&1 || true
        if [[ -s /tmp/fmt.out ]]; then
            CHECK_RESULTS[fmt]="failed"
        else
            CHECK_RESULTS[fmt]="passed"
        fi

        # Vet check
        go vet ./... > /tmp/vet.out 2>&1 || true
        if [[ -s /tmp/vet.out ]]; then
            CHECK_RESULTS[vet]="failed"
            parse_build_error "$(cat /tmp/vet.out)"
        else
            CHECK_RESULTS[vet]="passed"
        fi

        # Lint check
        golangci-lint run ./... > /tmp/lint.out 2>&1 || true
        if [[ -s /tmp/lint.out ]]; then
            CHECK_RESULTS[lint]="failed"
            parse_golangci_lint "$(cat /tmp/lint.out)"
        else
            CHECK_RESULTS[lint]="passed"
        fi

        # Tests (without race - will be run separately for better control)
        go test -short ./... > /tmp/test.out 2>&1 || true
        if [[ -s /tmp/test.out ]] && grep -q "FAIL" /tmp/test.out; then
            CHECK_RESULTS[tests]="failed"
            parse_test_error "$(cat /tmp/test.out)"
        else
            CHECK_RESULTS[tests]="passed"
        fi

        # NEW ENHANCEMENTS: Thorough mode includes all checks
        [[ "$OUTPUT_FORMAT" != "json" ]] && echo ""

        # Early import cycle detection
        check_import_cycles || true

        # Coverage check (with TDD awareness)
        check_coverage || true

        # Security vulnerability scanning
        check_vulnerabilities || true

        # Race detection in ALWAYS mode for thorough
        RACE_DETECTION_MODE="always"
        check_race_conditions || true
    fi

    # Auto-fix if requested
    if [[ "$AUTO_FIX" == true ]]; then
        [[ "$OUTPUT_FORMAT" != "json" ]] && echo ""
        [[ "$OUTPUT_FORMAT" != "json" ]] && echo -e "${BLUE}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
        [[ "$OUTPUT_FORMAT" != "json" ]] && echo -e "${BLUE}${BOLD}üîß AUTO-FIX ATTEMPTING...${NC}"
        [[ "$OUTPUT_FORMAT" != "json" ]] && echo -e "${BLUE}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
        [[ "$OUTPUT_FORMAT" != "json" ]] && echo ""

        # Check if we have any issues
        local total_issues=${#ISSUES[@]}

        if [[ $total_issues -eq 0 ]]; then
            [[ "$OUTPUT_FORMAT" != "json" ]] && echo -e "${GREEN}‚úì No issues to fix!${NC}"
            [[ "$OUTPUT_FORMAT" != "json" ]] && echo ""
            return 0
        fi

        # Use jq to efficiently count issue types
        local auto_fixable_count=0
        local manual_count=0
        local formatting_issues=0
        local comment_issues=0

        if command -v jq &> /dev/null && [[ ${#ISSUES[@]} -gt 0 ]]; then
            # Convert issues array to JSON and count with jq
            local issues_json=$(printf '%s\n' "${ISSUES[@]}" | jq -s '.')
            auto_fixable_count=$(echo "$issues_json" | jq '[.[] | select(.autoFixable==true)] | length')
            manual_count=$(echo "$issues_json" | jq '[.[] | select(.autoFixable==false)] | length')
            formatting_issues=$(echo "$issues_json" | jq '[.[] | select(.type=="formatting" and .autoFixable==true)] | length')
            comment_issues=$(echo "$issues_json" | jq '[.[] | select(.type=="style" and (.message | contains("comment")))] | length')
        else
            # Fallback to bash string matching if jq unavailable
            for issue in "${ISSUES[@]}"; do
                if [[ "$issue" == *'"autoFixable":true'* ]]; then
                    ((auto_fixable_count++))
                    [[ "$issue" == *'"type":"formatting"'* ]] && ((formatting_issues++))
                else
                    ((manual_count++))
                fi
                [[ "$issue" == *'"type":"style"'* ]] && [[ "$issue" == *'comment'* ]] && ((comment_issues++))
            done
        fi

        [[ "$OUTPUT_FORMAT" != "json" ]] && echo -e "${CYAN}Analysis:${NC}"
        [[ "$OUTPUT_FORMAT" != "json" ]] && echo "  ‚Ä¢ ${auto_fixable_count} auto-fixable issue(s)"
        [[ "$OUTPUT_FORMAT" != "json" ]] && echo "  ‚Ä¢ ${manual_count} manual fix required"
        [[ "$OUTPUT_FORMAT" != "json" ]] && echo ""

        # Track fixes
        local fixed_count=0
        local skipped_count=0

        # Try to fix issues
        if [[ $auto_fixable_count -gt 0 ]]; then
            [[ "$OUTPUT_FORMAT" != "json" ]] && echo -e "${CYAN}Attempting fixes:${NC}"

            # Fix formatting issues
            if [[ $formatting_issues -gt 0 ]]; then
                [[ "$OUTPUT_FORMAT" != "json" ]] && echo -n "  ‚Ä¢ Formatting ($formatting_issues files)... "
                if autofix_formatting; then
                    [[ "$OUTPUT_FORMAT" != "json" ]] && echo -e "${GREEN}‚úì Fixed${NC}"
                    fixed_count=$((fixed_count + formatting_issues))
                else
                    [[ "$OUTPUT_FORMAT" != "json" ]] && echo -e "${RED}‚úó Failed${NC}"
                    skipped_count=$((skipped_count + formatting_issues))
                fi
            fi

            # Fix package comment issues
            if [[ $comment_issues -gt 0 ]]; then
                [[ "$OUTPUT_FORMAT" != "json" ]] && echo -n "  ‚Ä¢ Package comments ($comment_issues files)... "

                # Attempt to add missing package comments
                local comment_fix_count=0
                for issue in "${ISSUES[@]}"; do
                    if [[ "$issue" == *'"type":"style"'* ]] && [[ "$issue" == *'package comment'* ]]; then
                        local file=$(echo "$issue" | jq -r '.file' 2>/dev/null || echo "")
                        local line=$(echo "$issue" | jq -r '.line' 2>/dev/null || echo "0")

                        if [[ -n "$file" ]] && [[ -f "$file" ]] && [[ "$line" -gt 0 ]]; then
                            # Extract package name from the file
                            local pkg_name=$(grep -m 1 "^package " "$file" | awk '{print $2}')
                            if [[ -n "$pkg_name" ]]; then
                                # Add package comment before package declaration
                                local pkg_line=$(grep -n "^package " "$file" | head -1 | cut -d: -f1)
                                if [[ -n "$pkg_line" ]]; then
                                    sed -i "${pkg_line}i // Package ${pkg_name} provides implementation for the ${pkg_name} service." "$file"
                                    ((comment_fix_count++))
                                fi
                            fi
                        fi
                    fi
                done

                if [[ $comment_fix_count -gt 0 ]]; then
                    [[ "$OUTPUT_FORMAT" != "json" ]] && echo -e "${GREEN}‚úì Fixed $comment_fix_count${NC}"
                    fixed_count=$((fixed_count + comment_fix_count))
                else
                    [[ "$OUTPUT_FORMAT" != "json" ]] && echo -e "${YELLOW}‚äò Skipped${NC}"
                    skipped_count=$((skipped_count + comment_issues))
                fi
            fi

            [[ "$OUTPUT_FORMAT" != "json" ]] && echo ""
        fi

        # Summary
        [[ "$OUTPUT_FORMAT" != "json" ]] && echo -e "${BOLD}Auto-fix Summary:${NC}"
        if [[ $fixed_count -gt 0 ]]; then
            [[ "$OUTPUT_FORMAT" != "json" ]] && echo -e "  ${GREEN}‚úì Fixed: $fixed_count issue(s)${NC}"
        fi
        if [[ $skipped_count -gt 0 ]]; then
            [[ "$OUTPUT_FORMAT" != "json" ]] && echo -e "  ${YELLOW}‚äò Skipped: $skipped_count issue(s)${NC}"
        fi
        if [[ $manual_count -gt 0 ]]; then
            [[ "$OUTPUT_FORMAT" != "json" ]] && echo -e "  ${BLUE}‚ö† Manual: $manual_count issue(s) require manual fixes${NC}"
        fi

        if [[ $fixed_count -eq 0 ]] && [[ ${#ISSUES[@]} -gt 0 ]]; then
            [[ "$OUTPUT_FORMAT" != "json" ]] && echo ""
            [[ "$OUTPUT_FORMAT" != "json" ]] && echo -e "${YELLOW}‚ÑπÔ∏è  No issues could be auto-fixed. Manual intervention required.${NC}"
            [[ "$OUTPUT_FORMAT" != "json" ]] && echo -e "${CYAN}   Common manual fixes:${NC}"
            [[ "$OUTPUT_FORMAT" != "json" ]] && echo "   ‚Ä¢ errcheck: Add error handling (if err != nil)"
            [[ "$OUTPUT_FORMAT" != "json" ]] && echo "   ‚Ä¢ package-comments: Add '// Package name provides...'"
            [[ "$OUTPUT_FORMAT" != "json" ]] && echo "   ‚Ä¢ bodyclose: Add 'defer resp.Body.Close()'"
        fi

        # Re-run validation to update issues after fixes
        if [[ $fixed_count -gt 0 ]]; then
            [[ "$OUTPUT_FORMAT" != "json" ]] && echo ""
            [[ "$OUTPUT_FORMAT" != "json" ]] && echo -e "${CYAN}Re-validating after fixes...${NC}"

            # Clear issues array and re-run checks
            ISSUES=()
            FAILED=0

            # Re-run format check
            UNFORMATTED=$(gofmt -l $STAGED_GO_FILES)
            if [ -z "$UNFORMATTED" ]; then
                CHECK_RESULTS[fmt]="passed"
                [[ "$OUTPUT_FORMAT" != "json" ]] && echo -e "  ${GREEN}‚úì${NC} Format check: passed"
            fi

            [[ "$OUTPUT_FORMAT" != "json" ]] && echo ""
        fi

        [[ "$OUTPUT_FORMAT" != "json" ]] && echo ""
    fi
}

# Handle special modes
if [[ -n "$EXPLAIN_TEST" ]]; then
    run_validation
    handle_explain "$EXPLAIN_TEST"
elif [[ -n "$SUGGEST_FIX" ]]; then
    run_validation
    handle_suggest_fix "$SUGGEST_FIX"
fi

# Run validation
run_validation

# CRITICAL: Ensure FAILED is set if any check failed
# This handles cases where parsers didn't extract issues but checks failed
for check in fmt vet lint tests build coverage security cycles race; do
    if [[ "${CHECK_RESULTS[$check]}" == "failed" ]]; then
        FAILED=1
        break
    fi
done


# Output results
if [[ "$OUTPUT_LSP" == true ]]; then
    output_lsp
elif [[ "$OUTPUT_FORMAT" == "json" ]]; then
    output_json
else
    output_human
fi

# Cleanup temp files
rm -f /tmp/{fmt,vet,lint,test}.out

# Exit with failure if issues found
if [[ $FAILED -eq 1 ]]; then
    [[ "$OUTPUT_FORMAT" != "json" ]] && {
        echo -e "${RED}================================================${NC}"
        echo -e "${RED}‚úó Pre-commit validation FAILED${NC}"
        echo -e "${RED}================================================${NC}"
        echo ""
        echo "To bypass: git commit --no-verify"
    }
    exit 1
fi

[[ "$OUTPUT_FORMAT" != "json" ]] && {
    echo -e "${GREEN}================================================${NC}"
    echo -e "${GREEN}‚úÖ Pre-commit validation PASSED${NC}"
    echo -e "${GREEN}================================================${NC}"
}

exit 0

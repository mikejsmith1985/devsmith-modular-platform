#!/bin/bash
# DevSmith Pre-Push Validation Hook
# Runs full code validation ONLY when pushing to GitHub (not on every local commit)
# Provides beautiful color-coded dashboard for humans + structured JSON output for agents
#
# Features:
#   - Only runs on `git push` (not on commit)
#   - Fast local commits (no validation delay)
#   - Comprehensive validation at push time
#   - Color-coded human-readable output (green/red/yellow)
#   - Structured JSON output for CI/CD pipelines and agents
#   - Configurable validation levels (--quick, --standard, --thorough)
#   - TIMEOUT PROTECTION to prevent hanging

set -euo pipefail

# ============================================================================
# CONFIGURATION
# ============================================================================

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/../.." && pwd)"
cd "$PROJECT_ROOT"

# Parse arguments
MODE="${1:-standard}"
OUTPUT_FORMAT="human"
if [[ "$MODE" == "--json" ]]; then
    OUTPUT_FORMAT="json"
    MODE="standard"
elif [[ "$MODE" == "--quick" ]]; then
    MODE="quick"
    OUTPUT_FORMAT="human"
elif [[ "$MODE" == "--thorough" ]]; then
    MODE="thorough"
    OUTPUT_FORMAT="human"
fi

# ============================================================================
# TIMEOUT CONFIGURATION
# ============================================================================

# Timeout for each validation step (seconds)
TIMEOUT_FORMAT=10
TIMEOUT_VET=15
TIMEOUT_LINT=30
TIMEOUT_BUILD=60
TIMEOUT_TESTS_SHORT=45
TIMEOUT_TESTS_FULL=120
TIMEOUT_SECURITY=30

# ============================================================================
# COLOR DEFINITIONS
# ============================================================================

if [[ "$OUTPUT_FORMAT" == "json" ]]; then
    # No colors for JSON
    RED=''; GREEN=''; YELLOW=''; BLUE=''; CYAN=''; BOLD=''; NC=''
else
    # Colors for human output
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    BLUE='\033[0;34m'
    CYAN='\033[0;36m'
    BOLD='\033[1m'
    NC='\033[0m'
fi

# ============================================================================
# STATE & TRACKING
# ============================================================================

declare -a ISSUES=()
declare -A CHECK_RESULTS=(
    [format]="pending"
    [imports]="pending"
    [vet]="pending"
    [test_compile]="pending"
    [lint]="pending"
    [build]="pending"
    [tests]="pending"
    [race]="pending"
    [security]="pending"
    [coverage]="pending"
)

FAILED=0
START_TIME=$(date +%s)

# ============================================================================
# HELPER FUNCTIONS
# ============================================================================

# Helper: Add issue for tracking
add_issue() {
    local check="$1"
    local severity="$2"  # error, warning, info
    local message="$3"
    local details="${4:-}"
    
    local issue_json=$(cat <<EOF
{
    "check": "$check",
    "severity": "$severity",
    "message": "$message",
    "details": "$details"
}
EOF
)
    ISSUES+=("$issue_json")
    
    if [[ "$severity" == "error" ]]; then
        FAILED=1
        CHECK_RESULTS[$check]="failed"
    fi
}

# Helper: Print human-readable heading
print_heading() {
    local text="$1"
    if [[ "$OUTPUT_FORMAT" != "json" ]]; then
        echo ""
        echo -e "${BOLD}${BLUE}▶ $text${NC}"
    fi
}

# Helper: Print success message
print_success() {
    local check="$1"
    local message="$2"
    if [[ "$OUTPUT_FORMAT" != "json" ]]; then
        echo -e "  ${GREEN}✓${NC} $message"
    fi
    CHECK_RESULTS[$check]="passed"
}

# Helper: Print warning message
print_warning() {
    local check="$1"
    local message="$2"
    if [[ "$OUTPUT_FORMAT" != "json" ]]; then
        echo -e "  ${YELLOW}⚠${NC} $message"
    fi
}

# Helper: Print error message
print_error() {
    local check="$1"
    local message="$2"
    if [[ "$OUTPUT_FORMAT" != "json" ]]; then
        echo -e "  ${RED}✗${NC} $message"
    fi
    add_issue "$check" "error" "$message" ""
}

# ============================================================================
# VALIDATION FUNCTIONS
# ============================================================================

validate_format() {
    print_heading "Code Formatting"
    
    local unformatted=$(timeout $TIMEOUT_FORMAT gofmt -l $(git diff --cached --name-only --diff-filter=ACM | grep '\.go$' || echo "./...") 2>/dev/null || true)
    
    if [[ -z "$unformatted" ]]; then
        print_success "format" "Code formatting OK"
        return 0
    else
        print_error "format" "Code not formatted (gofmt required)"
        return 1
    fi
}

validate_vet() {
    print_heading "Static Analysis (go vet)"
    
    if timeout $TIMEOUT_VET go vet ./... &>/dev/null; then
        print_success "vet" "No issues detected by go vet"
        return 0
    else
        local exit_code=$?
        if [[ $exit_code -eq 124 ]]; then
            print_warning "vet" "go vet timed out (${TIMEOUT_VET}s limit)"
            return 0
        else
            print_error "vet" "go vet found issues"
            return 1
        fi
    fi
}

validate_build() {
    print_heading "Build Verification"
    
    # Build all services
    local services=("portal" "review" "logs" "analytics")
    local failed_count=0
    
    for service in "${services[@]}"; do
        if timeout $TIMEOUT_BUILD go build "./cmd/$service/..." &>/dev/null; then
            print_success "build" "Service: $service ✓"
        else
            local exit_code=$?
            if [[ $exit_code -eq 124 ]]; then
                print_warning "build" "Service: $service (timed out)"
            else
                print_error "build" "Service: $service ✗"
                ((failed_count++))
            fi
        fi
    done
    
    [[ $failed_count -eq 0 ]] && return 0 || return 1
}

validate_lint() {
    print_heading "Linting (golangci-lint)"
    
    if ! command -v golangci-lint &>/dev/null; then
        print_warning "lint" "golangci-lint not installed (install: go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest)"
        return 0
    fi
    
    local lint_output=$(timeout $TIMEOUT_LINT golangci-lint run ./... 2>&1 || true)
    local exit_code=$?
    
    if [[ $exit_code -eq 124 ]]; then
        print_warning "lint" "Linting timed out (${TIMEOUT_LINT}s limit)"
        return 0
    elif [[ -z "$lint_output" ]] || ! echo "$lint_output" | grep -q "issues found"; then
        print_success "lint" "No linting issues"
        return 0
    else
        print_error "lint" "Linting found issues"
        return 1
    fi
}

validate_tests() {
    print_heading "Running Tests"
    
    local test_mode="-short"
    local timeout=$TIMEOUT_TESTS_SHORT
    [[ "$MODE" == "thorough" ]] && { test_mode=""; timeout=$TIMEOUT_TESTS_FULL; }
    
    if timeout $timeout go test $test_mode ./... &>/dev/null; then
        print_success "tests" "All tests passed"
        return 0
    else
        local exit_code=$?
        if [[ $exit_code -eq 124 ]]; then
            print_warning "tests" "Tests timed out (${timeout}s limit - try --thorough if needed)"
            return 0
        else
            print_error "tests" "Some tests failed"
            return 1
        fi
    fi
}

validate_security() {
    print_heading "Security Scanning (govulncheck)"
    
    if ! command -v govulncheck &>/dev/null; then
        print_warning "security" "govulncheck not installed (install: go install golang.org/x/vuln/cmd/govulncheck@latest)"
        return 0
    fi
    
    if timeout $TIMEOUT_SECURITY govulncheck ./... &>/dev/null; then
        print_success "security" "No known vulnerabilities"
        return 0
    else
        local exit_code=$?
        if [[ $exit_code -eq 124 ]]; then
            print_warning "security" "Vulnerability scan timed out (${TIMEOUT_SECURITY}s limit)"
        else
            print_warning "security" "Vulnerability scan found issues (non-blocking)"
        fi
        return 0
    fi
}

validate_coverage() {
    print_heading "Test Coverage"
    
    local coverage_file=".git/pre-push-coverage.out"
    
    if timeout 30s go test -coverprofile="$coverage_file" -covermode=atomic ./... &>/dev/null; then
        local coverage=$(go tool cover -func="$coverage_file" 2>/dev/null | grep total | awk '{print $3}' | sed 's/%//')
        
        if [[ -n "$coverage" ]]; then
            if (( $(echo "$coverage >= 55" | bc -l 2>/dev/null || echo 0) )); then
                print_success "coverage" "Coverage: ${coverage}% ✓"
            else
                print_warning "coverage" "Coverage: ${coverage}% (target: 55%, non-blocking warning)"
            fi
        fi
    fi
    
    rm -f "$coverage_file"
    return 0
}

validate_imports() {
    print_heading "Import Resolution (goimports)"
    
    local unresolved=$(timeout $TIMEOUT_FORMAT goimports -l $(git diff --cached --name-only --diff-filter=ACM | grep '\.go$' || echo "./...") 2>/dev/null || true)
    
    if [[ -z "$unresolved" ]]; then
        print_success "imports" "All imports resolved correctly"
        return 0
    else
        print_error "imports" "Unresolved or unformatted imports detected"
        return 1
    fi
}

validate_test_compilation() {
    print_heading "Test Compilation"
    
    if timeout $TIMEOUT_BUILD go test -c ./... &>/dev/null 2>&1; then
        print_success "test_compile" "All test packages compile successfully"
        return 0
    else
        local exit_code=$?
        if [[ $exit_code -eq 124 ]]; then
            print_warning "test_compile" "Test compilation timed out (${TIMEOUT_BUILD}s limit)"
            return 0
        else
            print_error "test_compile" "Test compilation failed - check function signatures and dependencies"
            return 1
        fi
    fi
}

validate_race_conditions() {
    print_heading "Race Condition Detection"
    
    if [[ "$MODE" != "quick" ]]; then
        if timeout $TIMEOUT_TESTS_SHORT go test -race -short ./... &>/dev/null 2>&1; then
            print_success "race" "No race conditions detected"
            return 0
        else
            local exit_code=$?
            if [[ $exit_code -eq 124 ]]; then
                print_warning "race" "Race detection timed out (${TIMEOUT_TESTS_SHORT}s limit)"
                return 0
            else
                print_error "race" "Race conditions detected - review test output"
                return 1
            fi
        fi
    else
        print_warning "race" "Race detection skipped in quick mode"
        return 0
    fi
}

# ============================================================================
# OUTPUT FORMATTERS
# ============================================================================

output_dashboard_header() {
    if [[ "$OUTPUT_FORMAT" != "json" ]]; then
        echo ""
        echo -e "${BOLD}${CYAN}════════════════════════════════════════════════════════════════${NC}"
        echo -e "${BOLD}${CYAN}  📊 PRE-PUSH VALIDATION DASHBOARD${NC}"
        echo -e "${BOLD}${CYAN}════════════════════════════════════════════════════════════════${NC}"
    fi
}

output_summary() {
    if [[ "$OUTPUT_FORMAT" != "json" ]]; then
        echo ""
        echo -e "${BOLD}SUMMARY:${NC}"
        local passed=0
        local failed=0
        
        for check in "${!CHECK_RESULTS[@]}"; do
            if [[ "${CHECK_RESULTS[$check]}" == "passed" ]]; then
                ((passed++))
                echo -e "  ${GREEN}✓${NC} $check"
            elif [[ "${CHECK_RESULTS[$check]}" == "failed" ]]; then
                ((failed++))
                echo -e "  ${RED}✗${NC} $check"
            fi
        done
        
        echo ""
        if [[ $failed -eq 0 ]]; then
            echo -e "${GREEN}${BOLD}✅ ALL CHECKS PASSED - Ready to push!${NC}"
        else
            echo -e "${RED}${BOLD}❌ $failed CHECK(S) FAILED - Fix issues before pushing${NC}"
        fi
    fi
}

output_json_report() {
    local end_time=$(date +%s)
    local duration=$((end_time - START_TIME))
    
    cat <<EOF
{
  "validation": "pre-push",
  "status": "$([ $FAILED -eq 0 ] && echo "passed" || echo "failed")",
  "timestamp": "$(date -Iseconds)",
  "duration_seconds": $duration,
  "mode": "$MODE",
  "checks": {
EOF
    
    local first=true
    for check in "${!CHECK_RESULTS[@]}"; do
        if [[ "$first" == "true" ]]; then
            first=false
        else
            echo ","
        fi
        echo -n "    \"$check\": \"${CHECK_RESULTS[$check]}\""
    done
    
    echo ""
    echo "  },"
    echo "  \"issues\": ["
    
    local first=true
    for issue in "${ISSUES[@]}"; do
        if [[ "$first" == "true" ]]; then
            first=false
        else
            echo ","
        fi
        echo -n "    $issue"
    done
    
    echo ""
    echo "  ]"
    echo "}"
}

# ============================================================================
# MAIN EXECUTION
# ============================================================================

main() {
    [[ "$OUTPUT_FORMAT" != "json" ]] && output_dashboard_header
    
    # Quick mode: format + build only (fastest)
    if [[ "$MODE" == "quick" ]]; then
        validate_format || true
        validate_imports || true
        validate_build || true
    
    # Standard mode: format + imports + vet + test compile + lint + build + tests + race + security
    elif [[ "$MODE" == "standard" ]]; then
        validate_format || true
        validate_imports || true
        validate_vet || true
        validate_test_compilation || true
        validate_lint || true
        validate_build || true
        validate_tests || true
        validate_race_conditions || true
        validate_security || true
        validate_coverage || true
    
    # Thorough mode: everything including long-running tests
    elif [[ "$MODE" == "thorough" ]]; then
        validate_format || true
        validate_imports || true
        validate_vet || true
        validate_test_compilation || true
        validate_lint || true
        validate_build || true
        validate_tests || true  # Full tests, not short
        validate_race_conditions || true
        validate_security || true
        validate_coverage || true
    fi
    
    # Output results
    if [[ "$OUTPUT_FORMAT" == "json" ]]; then
        output_json_report
    else
        output_summary
        echo -e "${CYAN}════════════════════════════════════════════════════════════════${NC}"
        echo ""
    fi
    
    # Exit with appropriate code
    exit $FAILED
}

main "$@"

#!/bin/bash
# Pre-commit hook: Full build validation with smart error reporting
# Prevents commits with build errors, unused code, or misplaced code
# Provides detailed diagnostics and actionable fix suggestions

set -e

echo "üîç Pre-commit validation starting..."
echo ""

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m' # No Color

FAILED=0

# Smart error tracking
declare -a ERRORS=()
declare -a WARNINGS=()
declare -a SUGGESTIONS=()
ERROR_COUNT=0
WARNING_COUNT=0

# Parse build errors with intelligent categorization
parse_build_error() {
    local error_output="$1"
    local context="${2:-build}"

    while IFS= read -r line; do
        [[ -z "$line" ]] && continue

        # Undefined reference/identifier
        if [[ "$line" =~ undefined:\ ([^[:space:]]+) ]]; then
            local identifier="${BASH_REMATCH[1]}"
            local file=$(echo "$line" | grep -oP '^[^:]+' | head -1)
            local linenum=$(echo "$line" | grep -oP '(?<=:)[0-9]+' | head -1)

            ERRORS+=("${file}:${linenum} - undefined: ${identifier}")
            SUGGESTIONS+=("Implement ${identifier} function/method or add missing import")
            ((ERROR_COUNT++))

        # Import cycle detection
        elif [[ "$line" =~ import\ cycle|cycle\ not\ allowed ]]; then
            ERRORS+=("Import cycle detected in package dependencies")
            SUGGESTIONS+=("Break cycle by moving shared types to common/shared package")
            ((ERROR_COUNT++))

        # Type mismatch
        elif [[ "$line" =~ "cannot use".+"type ".*"as".+"type " ]]; then
            local file=$(echo "$line" | grep -oP '^[^:]+' | head -1)

            ERRORS+=("${file} - type mismatch in assignment or function call")
            SUGGESTIONS+=("Check types match or adjust function signature")
            ((ERROR_COUNT++))

        # Missing return statement
        elif [[ "$line" =~ missing\ return ]]; then
            local file=$(echo "$line" | grep -oP '^[^:]+' | head -1)
            local linenum=$(echo "$line" | grep -oP '(?<=:)[0-9]+' | head -1)

            ERRORS+=("${file}:${linenum} - missing return statement")
            SUGGESTIONS+=("Add return statement for all code paths")
            ((ERROR_COUNT++))

        # Unused variable/import (warning)
        elif [[ "$line" =~ ([^[:space:]]+)\ declared\ (and|but)\ not\ used ]] || [[ "$line" =~ imported\ and\ not\ used:\ \"([^\"]+)\" ]]; then
            local item="${BASH_REMATCH[1]}"
            [[ -n "${BASH_REMATCH[3]:-}" ]] && item="${BASH_REMATCH[3]}"
            local file=$(echo "$line" | grep -oP '^[^:]+' | head -1)

            WARNINGS+=("${file} - unused: ${item}")
            SUGGESTIONS+=("Remove unused code or run: goimports -w .")
            ((WARNING_COUNT++))

        # Syntax errors
        elif [[ "$line" =~ syntax\ error ]]; then
            local file=$(echo "$line" | grep -oP '^[^:]+' | head -1)
            local linenum=$(echo "$line" | grep -oP '(?<=:)[0-9]+' | head -1)

            ERRORS+=("${file}:${linenum} - syntax error")
            SUGGESTIONS+=("Check for missing brackets, semicolons, or malformed expressions")
            ((ERROR_COUNT++))
        fi
    done <<< "$error_output"
}

# Parse test failures with intelligent diagnostics
parse_test_error() {
    local test_output="$1"
    local current_test=""
    local in_failure=0

    while IFS= read -r line; do
        # Test failure header
        if [[ "$line" =~ ---\ FAIL:\ ([^[:space:]]+) ]]; then
            current_test="${BASH_REMATCH[1]}"
            in_failure=1

        # Mock-related failures
        elif [[ "$in_failure" -eq 1 ]] && [[ "$line" =~ (mock|Mock).*(assert|call|expect|Called) ]]; then
            ERRORS+=("Test '${current_test}' - mock expectation failure")
            SUGGESTIONS+=("Check mock setup - see .docs/copilot-instructions.md ¬ß5.1")
            SUGGESTIONS+=("Ensure m.Called() is used and return values match expectations")
            ((ERROR_COUNT++))
            in_failure=0

        # Panic in test
        elif [[ "$line" =~ panic:\ (.+) ]]; then
            local panic_msg="${BASH_REMATCH[1]}"
            ERRORS+=("Test panic: ${panic_msg}")
            SUGGESTIONS+=("Check for nil pointer dereference or uninitialized variables")
            ((ERROR_COUNT++))

        # Assertion failures with expected vs actual
        elif [[ "$in_failure" -eq 1 ]] && [[ "$line" =~ (Expected|expected|got|want) ]]; then
            ERRORS+=("Test '${current_test}' - assertion mismatch")
            SUGGESTIONS+=("Review test expectations: ${line:0:80}")
            ((ERROR_COUNT++))
            in_failure=0

        # Test ended
        elif [[ "$line" =~ PASS|FAIL ]]; then
            in_failure=0
        fi
    done <<< "$test_output"
}

# Print comprehensive error dashboard
print_error_dashboard() {
    if [[ $ERROR_COUNT -eq 0 ]] && [[ $WARNING_COUNT -eq 0 ]]; then
        return 0
    fi

    echo ""
    echo -e "${BOLD}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
    echo -e "${BOLD}üìä VALIDATION ISSUE SUMMARY${NC}"
    echo -e "${BOLD}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
    echo ""

    # Status summary
    local status_line=""
    [[ $ERROR_COUNT -gt 0 ]] && status_line="${RED}‚ùå ${ERROR_COUNT} error(s)${NC}"
    [[ $WARNING_COUNT -gt 0 ]] && status_line="${status_line}${status_line:+, }${YELLOW}‚ö†Ô∏è  ${WARNING_COUNT} warning(s)${NC}"
    echo -e "${status_line}"
    echo ""

    # Print errors with suggestions
    if [[ $ERROR_COUNT -gt 0 ]]; then
        echo -e "${RED}${BOLD}ERRORS:${NC}"
        local printed_errors=0
        for i in "${!ERRORS[@]}"; do
            echo -e "  $((printed_errors+1)). ${ERRORS[$i]}"
            if [[ $i -lt ${#SUGGESTIONS[@]} ]]; then
                echo -e "     ${CYAN}‚Üí ${SUGGESTIONS[$i]}${NC}"
            fi
            ((printed_errors++))
        done
        echo ""
    fi

    # Print warnings
    if [[ $WARNING_COUNT -gt 0 ]]; then
        echo -e "${YELLOW}${BOLD}WARNINGS:${NC}"
        local printed_warnings=0
        local start_idx=$ERROR_COUNT
        for i in "${!WARNINGS[@]}"; do
            echo -e "  $((printed_warnings+1)). ${WARNINGS[$i]}"
            local sugg_idx=$((start_idx + i))
            if [[ $sugg_idx -lt ${#SUGGESTIONS[@]} ]]; then
                echo -e "     ${CYAN}‚Üí ${SUGGESTIONS[$sugg_idx]}${NC}"
            fi
            ((printed_warnings++))
        done
        echo ""
    fi

    # Quick fixes section
    echo -e "${BLUE}${BOLD}QUICK FIXES:${NC}"
    echo -e "  ‚Ä¢ Format code:       ${CYAN}go fmt ./...${NC}"
    echo -e "  ‚Ä¢ Fix imports:       ${CYAN}goimports -w .${NC}"
    echo -e "  ‚Ä¢ Run tests:         ${CYAN}go test ./...${NC}"
    echo -e "  ‚Ä¢ Build service:     ${CYAN}go build ./cmd/<service>${NC}"
    echo -e "  ‚Ä¢ Run linter:        ${CYAN}golangci-lint run ./...${NC}"
    echo ""

    echo -e "${BLUE}${BOLD}DOCUMENTATION:${NC}"
    echo -e "  ‚Ä¢ Mock patterns:     ${CYAN}.docs/copilot-instructions.md ¬ß5.1${NC}"
    echo -e "  ‚Ä¢ TDD workflow:      ${CYAN}.docs/copilot-instructions.md ¬ß4${NC}"
    echo -e "${BOLD}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
    echo ""
}

# 1. Check for staged Go files
STAGED_GO_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep '\.go$' || true)

if [ -z "$STAGED_GO_FILES" ]; then
  echo -e "${GREEN}‚úì No Go files staged, skipping build checks${NC}"
  exit 0
fi

echo "üìÅ Staged Go files:"
echo "$STAGED_GO_FILES" | sed 's/^/  - /'
echo ""

# 2. Run go fmt
echo "üîß Step 1/6: Checking code formatting..."
UNFORMATTED=$(gofmt -l $STAGED_GO_FILES)
if [ -n "$UNFORMATTED" ]; then
  echo -e "${RED}‚úó Code is not formatted. Run: go fmt ./...${NC}"
  echo "Unformatted files:"
  echo "$UNFORMATTED" | sed 's/^/  - /'
  FAILED=1
else
  echo -e "${GREEN}‚úì All files formatted${NC}"
fi
echo ""

# 3. Run go vet with smart error parsing
echo "üîç Step 2/7: Running go vet..."
VET_OUTPUT=$(go vet ./... 2>&1 || true)
if [ -n "$VET_OUTPUT" ]; then
  echo -e "${RED}‚úó go vet found issues${NC}"
  parse_build_error "$VET_OUTPUT" "vet"
  FAILED=1
else
  echo -e "${GREEN}‚úì go vet passed${NC}"
fi
echo ""

# 4. Run golangci-lint with smart error parsing
echo "üîç Step 3/7: Running golangci-lint..."
LINT_OUTPUT=$(golangci-lint run ./... 2>&1 || true)
if [ -n "$LINT_OUTPUT" ]; then
  echo -e "${RED}‚úó golangci-lint found issues${NC}"
  parse_build_error "$LINT_OUTPUT" "lint"
  FAILED=1
else
  echo -e "${GREEN}‚úì golangci-lint passed${NC}"
fi
echo ""

# 5. Check for unused code and imports
echo "üßπ Step 4/7: Checking for unused code..."
if ! go run golang.org/x/tools/cmd/goimports@latest -l $STAGED_GO_FILES | grep -q .; then
  echo -e "${GREEN}‚úì No unused imports${NC}"
else
  echo -e "${YELLOW}‚ö† Unused imports detected. Run: goimports -w .${NC}"
  go run golang.org/x/tools/cmd/goimports@latest -l $STAGED_GO_FILES
fi
echo ""

# 6. Full build check (CRITICAL - catches main.go issues)
echo "üî® Step 5/7: Running full build for all services..."

SERVICES=("portal" "review" "logs" "analytics")
BUILD_WARNINGS=0

for service in "${SERVICES[@]}"; do
  if [ -d "cmd/$service" ]; then
    echo "  ‚Üí Building $service..."

    # Check if service has test files but no implementation yet (TDD RED phase)
    SERVICE_DIR="internal/$service"
    if [ -d "$SERVICE_DIR" ]; then
      TEST_FILES=$(find "$SERVICE_DIR" -name "*_test.go" 2>/dev/null | wc -l)
      IMPL_FILES=$(find "$SERVICE_DIR" -name "*.go" ! -name "*_test.go" 2>/dev/null | wc -l)

      if [ "$TEST_FILES" -gt 0 ] && [ "$IMPL_FILES" -eq 0 ]; then
        echo -e "${YELLOW}    ‚ö† TDD RED phase detected: Tests exist but no implementation yet${NC}"
        echo -e "${YELLOW}    ‚Üí Skipping build check (implement service to pass tests)${NC}"
        continue
      fi
    fi

    # Try to build with smart error parsing
    BUILD_OUTPUT=$(go build -o /dev/null ./cmd/$service 2>&1 || true)
    if [ -n "$BUILD_OUTPUT" ]; then
      # Check if this is a TDD-related error (missing implementation)
      if echo "$BUILD_OUTPUT" | grep -q "undefined:" || echo "$BUILD_OUTPUT" | grep -q "not defined"; then
        echo -e "${YELLOW}    ‚ö† Build failed (possibly TDD RED phase)${NC}"
        echo -e "${YELLOW}    ‚Üí If you're writing tests first (TDD), implement the code to pass tests${NC}"
        BUILD_WARNINGS=1
      else
        echo -e "${RED}‚úó Build failed for $service${NC}"
        parse_build_error "$BUILD_OUTPUT" "build"
        FAILED=1
      fi
    else
      echo -e "${GREEN}    ‚úì $service builds successfully${NC}"
    fi
  fi
done

if [ $BUILD_WARNINGS -eq 1 ]; then
  echo ""
  echo -e "${YELLOW}‚ö† TDD Reminder:${NC}"
  echo -e "${YELLOW}  If you're in RED phase (tests written, no implementation):${NC}"
  echo -e "${YELLOW}    1. Commit tests: git commit -m 'test: add failing tests for [feature] (RED)'${NC}"
  echo -e "${YELLOW}    2. Implement feature to make tests pass${NC}"
  echo -e "${YELLOW}    3. Commit implementation: git commit -m 'feat: implement [feature] (GREEN)'${NC}"
fi

echo ""

# 7. Check for code outside functions (common copy-paste error)
echo "üîç Step 6/7: Checking for misplaced code..."
MISPLACED=0
for file in $STAGED_GO_FILES; do
  # Skip _test.go files
  if [[ $file == *_test.go ]]; then
    continue
  fi

  # Check for common patterns of code outside functions
  if grep -Hn "^\s*fmt\." "$file" | grep -v "^[^:]*:[0-9]*:\s*//" | grep -v "import" | grep -q .; then
    echo -e "${RED}‚úó Found fmt.* outside function in $file${NC}"
    grep -Hn "^\s*fmt\." "$file" | grep -v "^[^:]*:[0-9]*:\s*//"
    MISPLACED=1
  fi
done

if [ $MISPLACED -eq 0 ]; then
  echo -e "${GREEN}‚úì No misplaced code detected${NC}"
else
  FAILED=1
fi
echo ""

# 8. Run tests with smart error parsing
echo "üß™ Step 7/7: Running tests..."
TEST_OUTPUT=$(go test -short ./... 2>&1 || true)
if echo "$TEST_OUTPUT" | grep -q "FAIL"; then
  echo -e "${RED}‚úó Tests failed${NC}"
  parse_test_error "$TEST_OUTPUT"
  FAILED=1
else
  echo -e "${GREEN}‚úì Tests passed${NC}"
fi
echo ""

# Final verdict with smart error dashboard
if [ $FAILED -eq 1 ]; then
  # Print comprehensive error dashboard
  print_error_dashboard

  echo -e "${RED}================================================${NC}"
  echo -e "${RED}‚úó Pre-commit validation FAILED${NC}"
  echo -e "${RED}================================================${NC}"
  echo ""
  echo "Fix the issues above and try committing again."
  echo ""
  echo "To bypass this check (NOT RECOMMENDED):"
  echo "  git commit --no-verify"
  exit 1
fi

echo -e "${GREEN}================================================${NC}"
echo -e "${GREEN}‚úÖ Pre-commit validation PASSED${NC}"
echo -e "${GREEN}================================================${NC}"
echo ""

exit 0

#!/bin/bash
# Pre-commit hook: Full build validation with smart error reporting
# Prevents commits with build errors, unused code, or misplaced code
# Provides detailed diagnostics and actionable fix suggestions

set -e

echo "üîç Pre-commit validation starting..."
echo ""

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m' # No Color

FAILED=0

# Smart error tracking
declare -a ERRORS=()
declare -a WARNINGS=()
declare -a SUGGESTIONS=()
ERROR_COUNT=0
WARNING_COUNT=0

# Parse golangci-lint output (format: file:line:col: linter: message)
parse_golangci_lint() {
    local output="$1"

    while IFS= read -r line; do
        [[ -z "$line" ]] && continue

        # Pattern: file:line:col: linter: message
        if [[ "$line" =~ ^([^:]+):([0-9]+):([0-9]+):\ ([^:]+):\ (.+)$ ]]; then
            local file="${BASH_REMATCH[1]}"
            local linenum="${BASH_REMATCH[2]}"
            local linter="${BASH_REMATCH[4]}"
            local message="${BASH_REMATCH[5]}"

            # Categorize by linter severity
            case "$linter" in
                errcheck|typecheck|staticcheck)
                    ERRORS+=("${file}:${linenum} - ${linter}: ${message}")
                    SUGGESTIONS+=("Review code logic and error handling")
                    ((ERROR_COUNT++))
                    ;;
                gofmt|gofumpt)
                    WARNINGS+=("${file}:${linenum} - formatting: ${message}")
                    SUGGESTIONS+=("Run: go fmt ${file}")
                    ((WARNING_COUNT++))
                    ;;
                revive|golint|stylecheck|package-comments|exported)
                    WARNINGS+=("${file}:${linenum} - style: ${message}")
                    SUGGESTIONS+=("Add documentation or adjust code style")
                    ((WARNING_COUNT++))
                    ;;
                goconst|fieldalignment)
                    WARNINGS+=("${file}:${linenum} - optimization: ${message}")
                    SUGGESTIONS+=("Consider optimization (non-blocking)")
                    ((WARNING_COUNT++))
                    ;;
                *)
                    WARNINGS+=("${file}:${linenum} - ${linter}: ${message}")
                    SUGGESTIONS+=("Check golangci-lint documentation for ${linter}")
                    ((WARNING_COUNT++))
                    ;;
            esac
        fi
    done <<< "$output"
}

# Parse go build errors (format: file:line:col: error: details)
parse_build_error() {
    local output="$1"

    while IFS= read -r line; do
        [[ -z "$line" ]] && continue

        # Undefined reference
        if [[ "$line" =~ ^([^:]+):([0-9]+):([0-9]+):\ undefined:\ (.+)$ ]]; then
            local file="${BASH_REMATCH[1]}"
            local linenum="${BASH_REMATCH[2]}"
            local identifier="${BASH_REMATCH[4]}"

            ERRORS+=("${file}:${linenum} - undefined: ${identifier}")
            SUGGESTIONS+=("Implement ${identifier} function or add missing import")
            ((ERROR_COUNT++))

        # Unused import
        elif [[ "$line" =~ ^([^:]+):([0-9]+):([0-9]+):\ imported\ and\ not\ used:\ \"(.+)\"$ ]]; then
            local file="${BASH_REMATCH[1]}"
            local linenum="${BASH_REMATCH[2]}"
            local pkg="${BASH_REMATCH[4]}"

            WARNINGS+=("${file}:${linenum} - unused import: ${pkg}")
            SUGGESTIONS+=("Remove unused import or run: goimports -w ${file}")
            ((WARNING_COUNT++))

        # Declared but not used
        elif [[ "$line" =~ ^([^:]+):([0-9]+):([0-9]+):\ ([^\ ]+)\ declared\ (and|but)\ not\ used$ ]]; then
            local file="${BASH_REMATCH[1]}"
            local linenum="${BASH_REMATCH[2]}"
            local identifier="${BASH_REMATCH[4]}"

            WARNINGS+=("${file}:${linenum} - unused variable: ${identifier}")
            SUGGESTIONS+=("Remove unused variable or use it")
            ((WARNING_COUNT++))

        # Import cycle
        elif [[ "$line" =~ import\ cycle|cycle\ not\ allowed ]]; then
            ERRORS+=("Import cycle detected in package dependencies")
            SUGGESTIONS+=("Break cycle by moving shared types to common/shared package")
            ((ERROR_COUNT++))

        # Generic error (file:line:col: message)
        elif [[ "$line" =~ ^([^:]+):([0-9]+):([0-9]+):\ (.+)$ ]]; then
            local file="${BASH_REMATCH[1]}"
            local linenum="${BASH_REMATCH[2]}"
            local message="${BASH_REMATCH[4]}"

            ERRORS+=("${file}:${linenum} - ${message}")
            SUGGESTIONS+=("Review build error and fix syntax or type issues")
            ((ERROR_COUNT++))
        fi
    done <<< "$output"
}

# Parse test failures with intelligent diagnostics
parse_test_error() {
    local test_output="$1"
    local current_test=""
    local mock_failures=0

    while IFS= read -r line; do
        # Test failure header: --- FAIL: TestName (0.00s)
        if [[ "$line" =~ ^---\ FAIL:\ ([^\ ]+) ]]; then
            current_test="${BASH_REMATCH[1]}"
            mock_failures=0

        # Mock panic (unexpected call)
        elif [[ "$line" =~ panic.*mock.*unexpected ]]; then
            ERRORS+=("Test '${current_test}' - unexpected mock method call (panic)")
            SUGGESTIONS+=("Add Mock.On() expectation for the method - see .docs/copilot-instructions.md ¬ß5.1")
            ((ERROR_COUNT++))

        # Mock expectation summary: "X out of Y expectation(s) were met"
        elif [[ "$line" =~ FAIL:\ ([0-9]+)\ out\ of\ ([0-9]+)\ expectation ]]; then
            local met="${BASH_REMATCH[1]}"
            local total="${BASH_REMATCH[2]}"
            local unmet=$((total - met))

            ERRORS+=("Test '${current_test}' - ${unmet} mock expectation(s) not met")
            SUGGESTIONS+=("Check mock setup - see .docs/copilot-instructions.md ¬ß5.1")
            SUGGESTIONS+=("Ensure m.Called() is used and return values match expectations")
            ((ERROR_COUNT++))

        # Individual mock failure: file.go:line: FAIL: MethodName(...)
        elif [[ "$current_test" != "" ]] && [[ "$line" =~ ^[[:space:]]*([^:]+):([0-9]+):.*FAIL:.*\b([A-Z][a-zA-Z0-9_]*)\( ]]; then
            ((mock_failures++))
            # Only report first 2 individual failures to avoid spam (summary is more useful)
            if [[ $mock_failures -le 2 ]]; then
                local file="${BASH_REMATCH[1]}"
                local linenum="${BASH_REMATCH[2]}"
                local method="${BASH_REMATCH[3]}"

                ERRORS+=("Test '${current_test}' - mock '${method}' call mismatch at ${file}:${linenum}")
                SUGGESTIONS+=("Verify mock expectations match actual calls")
                ((ERROR_COUNT++))
            fi

        # Generic assertion failure
        elif [[ "$current_test" != "" ]] && [[ "$line" =~ ^[[:space:]]*([^:]+):([0-9]+):.*Error ]]; then
            local file="${BASH_REMATCH[1]}"
            local linenum="${BASH_REMATCH[2]}"

            ERRORS+=("Test '${current_test}' - assertion failed at ${file}:${linenum}")
            SUGGESTIONS+=("Check test assertions and expected values")
            ((ERROR_COUNT++))
        fi
    done <<< "$test_output"
}

# Print comprehensive error dashboard
print_error_dashboard() {
    if [[ $ERROR_COUNT -eq 0 ]] && [[ $WARNING_COUNT -eq 0 ]]; then
        return 0
    fi

    echo ""
    echo -e "${BOLD}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
    echo -e "${BOLD}üìä VALIDATION ISSUE SUMMARY${NC}"
    echo -e "${BOLD}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
    echo ""

    # Status summary
    local status_line=""
    [[ $ERROR_COUNT -gt 0 ]] && status_line="${RED}‚ùå ${ERROR_COUNT} error(s)${NC}"
    [[ $WARNING_COUNT -gt 0 ]] && status_line="${status_line}${status_line:+, }${YELLOW}‚ö†Ô∏è  ${WARNING_COUNT} warning(s)${NC}"
    echo -e "${status_line}"
    echo ""

    # Print errors with suggestions
    if [[ $ERROR_COUNT -gt 0 ]]; then
        echo -e "${RED}${BOLD}ERRORS:${NC}"
        local printed_errors=0
        for i in "${!ERRORS[@]}"; do
            echo -e "  $((printed_errors+1)). ${ERRORS[$i]}"
            if [[ $i -lt ${#SUGGESTIONS[@]} ]]; then
                echo -e "     ${CYAN}‚Üí ${SUGGESTIONS[$i]}${NC}"
            fi
            ((printed_errors++))
        done
        echo ""
    fi

    # Print warnings
    if [[ $WARNING_COUNT -gt 0 ]]; then
        echo -e "${YELLOW}${BOLD}WARNINGS:${NC}"
        local printed_warnings=0
        local start_idx=$ERROR_COUNT
        for i in "${!WARNINGS[@]}"; do
            echo -e "  $((printed_warnings+1)). ${WARNINGS[$i]}"
            local sugg_idx=$((start_idx + i))
            if [[ $sugg_idx -lt ${#SUGGESTIONS[@]} ]]; then
                echo -e "     ${CYAN}‚Üí ${SUGGESTIONS[$sugg_idx]}${NC}"
            fi
            ((printed_warnings++))
        done
        echo ""
    fi

    # Quick fixes section
    echo -e "${BLUE}${BOLD}QUICK FIXES:${NC}"
    echo -e "  ‚Ä¢ Format code:       ${CYAN}go fmt ./...${NC}"
    echo -e "  ‚Ä¢ Fix imports:       ${CYAN}goimports -w .${NC}"
    echo -e "  ‚Ä¢ Run tests:         ${CYAN}go test ./...${NC}"
    echo -e "  ‚Ä¢ Build service:     ${CYAN}go build ./cmd/<service>${NC}"
    echo -e "  ‚Ä¢ Run linter:        ${CYAN}golangci-lint run ./...${NC}"
    echo ""

    echo -e "${BLUE}${BOLD}DOCUMENTATION:${NC}"
    echo -e "  ‚Ä¢ Mock patterns:     ${CYAN}.docs/copilot-instructions.md ¬ß5.1${NC}"
    echo -e "  ‚Ä¢ TDD workflow:      ${CYAN}.docs/copilot-instructions.md ¬ß4${NC}"
    echo -e "${BOLD}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
    echo ""
}

# 1. Check for staged Go files
STAGED_GO_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep '\.go$' || true)

if [ -z "$STAGED_GO_FILES" ]; then
  echo -e "${GREEN}‚úì No Go files staged, skipping build checks${NC}"
  exit 0
fi

echo "üìÅ Staged Go files:"
echo "$STAGED_GO_FILES" | sed 's/^/  - /'
echo ""

# 2. Run go fmt
echo "üîß Step 1/6: Checking code formatting..."
UNFORMATTED=$(gofmt -l $STAGED_GO_FILES)
if [ -n "$UNFORMATTED" ]; then
  echo -e "${RED}‚úó Code is not formatted. Run: go fmt ./...${NC}"
  echo "Unformatted files:"
  echo "$UNFORMATTED" | sed 's/^/  - /'
  FAILED=1
else
  echo -e "${GREEN}‚úì All files formatted${NC}"
fi
echo ""

# 3. Run go vet with smart error parsing
echo "üîç Step 2/7: Running go vet..."
VET_OUTPUT=$(go vet ./... 2>&1 || true)
if [ -n "$VET_OUTPUT" ]; then
  echo -e "${RED}‚úó go vet found issues${NC}"
  parse_build_error "$VET_OUTPUT" "vet"
  FAILED=1
else
  echo -e "${GREEN}‚úì go vet passed${NC}"
fi
echo ""

# 4. Run golangci-lint with smart error parsing
echo "üîç Step 3/7: Running golangci-lint..."
LINT_OUTPUT=$(golangci-lint run ./... 2>&1 || true)
if [ -n "$LINT_OUTPUT" ]; then
  echo -e "${RED}‚úó golangci-lint found issues${NC}"
  parse_golangci_lint "$LINT_OUTPUT"
  FAILED=1
else
  echo -e "${GREEN}‚úì golangci-lint passed${NC}"
fi
echo ""

# 5. Check for unused code and imports
echo "üßπ Step 4/7: Checking for unused code..."
if ! go run golang.org/x/tools/cmd/goimports@latest -l $STAGED_GO_FILES | grep -q .; then
  echo -e "${GREEN}‚úì No unused imports${NC}"
else
  echo -e "${YELLOW}‚ö† Unused imports detected. Run: goimports -w .${NC}"
  go run golang.org/x/tools/cmd/goimports@latest -l $STAGED_GO_FILES
fi
echo ""

# 6. Full build check (CRITICAL - catches main.go issues)
echo "üî® Step 5/7: Running full build for all services..."

SERVICES=("portal" "review" "logs" "analytics")
BUILD_WARNINGS=0

for service in "${SERVICES[@]}"; do
  if [ -d "cmd/$service" ]; then
    echo "  ‚Üí Building $service..."

    # Check if service has test files but no implementation yet (TDD RED phase)
    SERVICE_DIR="internal/$service"
    if [ -d "$SERVICE_DIR" ]; then
      TEST_FILES=$(find "$SERVICE_DIR" -name "*_test.go" 2>/dev/null | wc -l)
      IMPL_FILES=$(find "$SERVICE_DIR" -name "*.go" ! -name "*_test.go" 2>/dev/null | wc -l)

      if [ "$TEST_FILES" -gt 0 ] && [ "$IMPL_FILES" -eq 0 ]; then
        echo -e "${YELLOW}    ‚ö† TDD RED phase detected: Tests exist but no implementation yet${NC}"
        echo -e "${YELLOW}    ‚Üí Skipping build check (implement service to pass tests)${NC}"
        continue
      fi
    fi

    # Try to build with smart error parsing
    BUILD_OUTPUT=$(go build -o /dev/null ./cmd/$service 2>&1 || true)
    if [ -n "$BUILD_OUTPUT" ]; then
      # Check if this is a TDD-related error (missing implementation)
      if echo "$BUILD_OUTPUT" | grep -q "undefined:" || echo "$BUILD_OUTPUT" | grep -q "not defined"; then
        echo -e "${YELLOW}    ‚ö† Build failed (possibly TDD RED phase)${NC}"
        echo -e "${YELLOW}    ‚Üí If you're writing tests first (TDD), implement the code to pass tests${NC}"
        BUILD_WARNINGS=1
      else
        echo -e "${RED}‚úó Build failed for $service${NC}"
        parse_build_error "$BUILD_OUTPUT" "build"
        FAILED=1
      fi
    else
      echo -e "${GREEN}    ‚úì $service builds successfully${NC}"
    fi
  fi
done

if [ $BUILD_WARNINGS -eq 1 ]; then
  echo ""
  echo -e "${YELLOW}‚ö† TDD Reminder:${NC}"
  echo -e "${YELLOW}  If you're in RED phase (tests written, no implementation):${NC}"
  echo -e "${YELLOW}    1. Commit tests: git commit -m 'test: add failing tests for [feature] (RED)'${NC}"
  echo -e "${YELLOW}    2. Implement feature to make tests pass${NC}"
  echo -e "${YELLOW}    3. Commit implementation: git commit -m 'feat: implement [feature] (GREEN)'${NC}"
fi

echo ""

# 7. Check for code outside functions (common copy-paste error)
echo "üîç Step 6/7: Checking for misplaced code..."
MISPLACED=0
for file in $STAGED_GO_FILES; do
  # Skip _test.go files
  if [[ $file == *_test.go ]]; then
    continue
  fi

  # Check for common patterns of code outside functions
  if grep -Hn "^\s*fmt\." "$file" | grep -v "^[^:]*:[0-9]*:\s*//" | grep -v "import" | grep -q .; then
    echo -e "${RED}‚úó Found fmt.* outside function in $file${NC}"
    grep -Hn "^\s*fmt\." "$file" | grep -v "^[^:]*:[0-9]*:\s*//"
    MISPLACED=1
  fi
done

if [ $MISPLACED -eq 0 ]; then
  echo -e "${GREEN}‚úì No misplaced code detected${NC}"
else
  FAILED=1
fi
echo ""

# 8. Run tests with smart error parsing
echo "üß™ Step 7/7: Running tests..."
TEST_OUTPUT=$(go test -short ./... 2>&1 || true)
if echo "$TEST_OUTPUT" | grep -q "FAIL"; then
  echo -e "${RED}‚úó Tests failed${NC}"
  parse_test_error "$TEST_OUTPUT"
  FAILED=1
else
  echo -e "${GREEN}‚úì Tests passed${NC}"
fi
echo ""

# Final verdict with smart error dashboard
if [ $FAILED -eq 1 ]; then
  # Print comprehensive error dashboard
  print_error_dashboard

  echo -e "${RED}================================================${NC}"
  echo -e "${RED}‚úó Pre-commit validation FAILED${NC}"
  echo -e "${RED}================================================${NC}"
  echo ""
  echo "Fix the issues above and try committing again."
  echo ""
  echo "To bypass this check (NOT RECOMMENDED):"
  echo "  git commit --no-verify"
  exit 1
fi

echo -e "${GREEN}================================================${NC}"
echo -e "${GREEN}‚úÖ Pre-commit validation PASSED${NC}"
echo -e "${GREEN}================================================${NC}"
echo ""

exit 0
